[{"title": "git-crypt 官方文档中文翻译", "path": "posts/2024/git-crypt_official_doc_zh.html", "tags": ["git-crypt", "git"], "content": "git-crypt 官方文档中文翻译 git-crypt - Git 中的透明文件加密 git-crypt 使 Git 仓库中的文件可以实现透明的加密和解密。您可以选择需要保护的文件，在提交时进行加密，在检出时进行解密。git-crypt 可以让您自由共享包含公共和私有内容的仓库。即使开发者没有密钥，git-crypt 也能让其实现克隆和提交含有加密文件的仓库。这样，您可以将秘密资料（如密钥或密码）存储在与代码相同的仓库中，而不需要锁定整个仓库。 git-crypt 是由 Andrew Ayer （ agwa@andrewayer.name ）编写的。\n更多信息，请访问 https://www.agwa.name/projects/git-crypt 。 构建 git-crypt 参考 INSTALL.md ​ 文件进行安装。 使用 git-crypt 配置仓库以使用 git-crypt： cd repo\ngit-crypt init 通过创建 .gitattributes 文件来指定要加密的文件： secretfile filter=git-crypt diff=git-crypt\n*.key filter=git-crypt diff=git-crypt\nsecretdir/** filter=git-crypt diff=git-crypt .gitattributes 文件跟 .gitignore 类似，可以匹配通配符，并且应该提交到仓库里。更多信息可以查看下方内容。请确认不要错误地加密了 .gitattributes 文件本身（或者其他 Git 文件，例如 .gitignore 或者 .gitmodules）。请确认你的 .gitattributes 规则已经生效 在提交敏感文件之前 ，否则这些文件将不会被加密！ 使用 GPG 分享仓库（给他人或自己）： git-crypt add-gpg-user USER_ID ​ USER_ID ​ 可以是一个密钥 ID、完整指纹、电子邮件地址或\n其他任何唯一标识 GPG 公钥的方式（参见 gpg 手册页中的 \"HOW TO\nSPECIFY A USER ID\"）。注意： git-crypt add-gpg-user ​ 会\n在仓库根目录的 .git-crypt 目录下添加并提交一个 GPG 加密的密钥文件。 另外，你可以导出一个对称密钥，安全地传递给协作者即可（无需 GPG，也不会在仓库中增加文件）： git-crypt export-key /path/to/key 克隆包含加密文件的存储库后，使用 GPG 进行解密： git-crypt unlock 或者使用对称密钥： git-crypt unlock /path/to/key 这就是你需要做的全部工作——在 git-crypt ​ 配置完成后（无论是通过 git-crypt init ​ 还是 git-crypt unlock ​），你可以像往常一样使用 git ​。加密和解密过程会透明地进行。 当前状态 git-crypt 的最新版本是 0.7.0 ，发布于\n2022-04-21。git-crypt 旨在实现无缺陷且可靠，即它不应崩溃、失效或泄露您的机密数据。然而，它尚未成熟，即它的文档、功能丰富性或易用性尚未达到应有的水平。此外，在 1.0 版本之前，可能会引入不向后兼容的变更。 安全性 git-crypt 比其他透明的 git 加密系统更安全。\ngit-crypt 使用 AES-256 在 CTR 模式下加密文件，并使用从文件的 SHA-1 HMAC 派生的合成 IV。\n这种操作模式在确定性选择明文攻击下被证明是语义安全的。\n这意味着尽管加密是确定性的（这是必需的，以便 git 可以区分文件是否已更改），\n但它不会泄露任何信息，只会暴露两个文件是否相同。\n其他透明的 git 加密方案使用 ECB 或 CBC 模式和固定 IV。这些系统在语义上不安全，会泄露信息。 局限性 git-crypt 依赖于 git 过滤器，而这些过滤器并非为加密设计。因此，git-crypt 并非加密版本库中大多数或全部文件的最佳工具。git-crypt 真正擅长的是这样一种场景：你的版本库绝大多数内容是公开的，但其中有一些文件（可能是一组命名为*. key 的私钥，或是一个含有 API 凭证的文件）需要加密。如果需要加密整个版本库，考虑使用 git-remote-gcrypt 这类工具。（注：本文不对 git-remote-gcrypt 的安全性作出评价。） git-crypt 不会加密文件名、提交信息、符号链接目标、gitlink 或其他元数据。 git-crypt 无法隐藏文件是否发生更改、文件长度，或者两个文件完全相同这一事实（参"}, {"title": "git-crypt 学习笔记", "path": "posts/2024/git-crypt_note.html", "tags": ["git", "git-crypt"], "content": "git-crypt 学习笔记 从 git-crypt 的 官方文档 中可知 git-crypt 使用 AES-256 在 CTR 模式下对文件进行加密，并且使用基于文件 SHA-1 HMAC 生成的合成初始化向量（IV）。这种操作模式在确定性选择明文攻击下被证明具有语义安全性，确保除了判断两个文件是否完全相同之外，不会泄露其他任何信息。 git-crypt 是结合了 GPG（GNU Privacy Guard）和 AES 加密技术的一个工具。它允许通过 GPG 公钥/私钥系统来管理和分发加密密钥，从而实现对 Git 仓库中特定文件的安全保护。对于每个需要加密的文件，git-crypt 利用 AES-256 加密算法在 CTR 模式下进行加密，以保证数据安全。 因此，git-crypt 在实际应用中整合了 GPG 的密钥管理和 AES 加密算法，实现了透明的文件加密与解密功能，使得在版本控制的同时能够保护敏感信息的安全。 也就是说，git-crypt 是一个将 GPG 和 AES 结合的项目，GPG 来管理用户权限，AES 来加密文件。 环境准备 gpg4win git git-crypt 要把从 git-crypt 下载的 git-crypt-0.7.0-x86_64.exe 重命名为 git-crypt.exe ，否则检测不到环境变量 把 git-crypt.exe 放到 git\\bin 目录下 步骤 1. 初始化仓库 git init 2. 初始化 git-crypt git-crypt init 3. 添加 GPG 用户 git-crypt add-gpg-user <GPG_KEY_ID> 4. 配置加密文件 在 .gitattributes 文件中添加 ## 加密指定文件\nsecretfile filter=git-crypt diff=git-crypt\n\n## 加密指定文件夹下的md文件\nTest/*.md filter=git-crypt diff=git-crypt\n\n## 加密指定文件夹下的所有文件\nTest/** filter=git-crypt diff=git-crypt 5. 提交更改 git add .gitattributes git commit -m \"Add git-crypt configuration\" git add . git commit -m \"commit all\" 6. 加密文件 git-crypt lock 7. 解密文件 git-crypt unlock 相关命令 $ git-crypt status\nnot encrypted: .gitattributes\n    encrypted: secretfile git-crypt 工作流示意图 （由 DeepSeek-R1 生成） graph TD\n    A[管理员] --> B[初始化仓库]\n    B --> C[创建.gitattributes文件]\n    C --> D[指定加密文件模式]\n    D --> E[添加GPG用户/导出密钥]\n\n    subgraph 有权限开发者\n        F[开发者] --> G[克隆仓库]\n        G --> H[git-crypt unlock]\n        H --> I[查看解密文件]\n        I --> J[修改文件]\n        J --> K[自动加密提交]\n    end\n\n    subgraph 无权限开发者\n        L[普通成员] --> M[克隆仓库]\n        M --> N[看到加密内容]\n        N --> O[修改非加密文件]\n        O --> P[正常提交]\n    end\n\n    E --> F\n    E --> L\n    K --> Q[远程仓库]\n    P --> Q\n    Q --> G\n    Q --> M Ubuntu 下使用 git-crypt 安装 git-crypt sudo apt-get update sudo apt-get install git-crypt 安装 gpg sudo apt update sudo apt install gpg 导入密钥 gpg --import 目前实测可以和 git-crypt 一起使用的 git、gpg 版本如下： Ubuntu git --version\n\ngit version 2.48.1 gpg --version\n\ngpg (GnuPG) 2.4.4\nlibgcrypt 1.11.0\nCopyright (C) 2024 g10 Code GmbH\nLicense GNU GPL-3.0-"}, {"title": "GitHub page 搭建学习笔记", "path": "posts/2024/deploy_gitHub_page.html", "tags": ["GitHub"], "content": "GitHub page 搭建学习笔记 git 生成 SSH 密钥 ssh-keygen -t ed25519 -C \"your_email@example.com\" -f ./id_rsa 其中 id_rsa 是私钥， id_rsa.pub 是公钥 私钥放在 markdown 帖子所在仓库 settings ——> Secrets and variables ——> Actions ——> New repository secret 添加 SSH 私钥，名称是： DEPLOY_KEY 公钥放在 username.github.io 仓库 settings ——> Deploy keys ——> Add deploy key 勾选 Allow write access GitHub Action 配置 name: Deploy to GitHub Pages\n\non:\n  push:\n    branches:\n      - main\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: 检出仓库\n      uses: actions/checkout@v4\n      with:\n        fetch-depth: 0\n\n    - name: 设置 Node.js 环境 # 根据 SSG 来确定环境 # [!code highlight]\n      uses: actions/setup-node@v3\n      with:\n        node-version: '>=20.18.0'\n\n    - name: 下载依赖 # [!code highlight]\n      run: |\n        npm install\n\n    - name: 构建 vitepress # [!code highlight]\n      run:  npx vitepress build\n\n    - name: 设置 SSH 密钥\n      run: |\n        mkdir -p ~/.ssh\n        echo \"${{ secrets.DEPLOY_KEY }}\" > ~/.ssh/id_rsa\n        chmod 600 ~/.ssh/id_rsa\n        ssh-keyscan github.com >> ~/.ssh/known_hosts\n\n    - name: 克隆目标仓库 # [!code highlight]\n      run: |\n        git clone git@github.com:wardenxyz/wardenxyz.github.io.git target_repo\n\n    - name: 复制生成的文件到目标仓库 # 根据 SSG 来确定复制文件路径 # [!code highlight]\n      run: |\n        rsync -av --delete html/* target_repo/\n\n    - name: 提交并推送更改到目标仓库\n      run: |\n        cd target_repo\n        git config --global user.name 'GitHub Actions'\n        git config --global user.email 'actions@github.com'\n        git add .\n        git commit -m \"Deploy - $(date -u '+%Y-%m-%d %H:%M:%S' -d '8 hour')\"\n        git push origin main"}, {"title": "vscode snippets 预置变量", "path": "posts/2024/vscode_snippets_variable.html", "tags": ["vscode"], "content": "vscode snippets 预置变量 在 Visual Studio Code 中，你可以使用许多预定义的变量来创建代码片段（snippets）。以下是一些常用的预定义变量： 常用变量 $TM_SELECTED_TEXT ：当前选中的文本。 $TM_CURRENT_LINE ：当前行的内容。 $TM_CURRENT_WORD ：光标下的单词内容。 $TM_LINE_INDEX ：当前行的索引（基于0）。 $TM_LINE_NUMBER ：当前行号（基于1）。 $TM_FILENAME ：当前文档的文件名。 $TM_FILENAME_BASE ：当前文档的文件名，不包含扩展名。 $TM_DIRECTORY ：当前文档的目录。 $TM_FILEPATH ：当前文档的完整文件路径。 $RELATIVE_FILEPATH ：当前文档相对于工作区根目录的路径。 $CLIPBOARD ：剪贴板的内容。 $WORKSPACE_NAME ：打开的工作区的名称。 $WORKSPACE_FOLDER ：打开的工作区的路径。 $CURSOR_INDEX ：光标索引（基于0）。 $CURSOR_NUMBER ：光标编号（基于1）。 日期和时间变量 $CURRENT_YEAR ：当前年份。 $CURRENT_YEAR_SHORT ：当前年份的最后两位数字。 $CURRENT_MONTH ：当前月份。 $CURRENT_MONTH_NAME ：当前月份的全称。（十月） $CURRENT_MONTH_NAME_SHORT ：当前月份的简称。（10月） $CURRENT_DATE ：当前日期。 $CURRENT_DAY_NAME ：当前星期几的全称。（星期一） $CURRENT_DAY_NAME_SHORT ：当前星期几的简称。（周一） $CURRENT_HOUR ：当前小时。 $CURRENT_MINUTE ：当前分钟。 $CURRENT_SECOND ：当前秒数。 $CURRENT_SECONDS_UNIX ：当前 Unix 时间戳。 $CURRENT_TIMEZONE_OFFSET ：当前的 UTC 时间偏移量表示为 +HH:MM 或 -HH:MM （例如 -07:00 ）。 随机数和 UUID $RANDOM ：一个随机整数。 $RANDOM_HEX ：一个随机的十六进制字符串。 $UUID ：一个随机的 UUID。 注释标记 $BLOCK_COMMENT_START ：块注释的开始标记。 $BLOCK_COMMENT_END ：块注释的结束标记。 $LINE_COMMENT ：行注释的标记。 以下代码片段在JavaScript文件中插入 /* Hello World */ ，并在HTML文件中插入 <!-- Hello World --> ： {\n    \"hello\": {\n        \"scope\": \"javascript,html\",\n        \"prefix\": \"hello\",\n        \"body\": \"$BLOCK_COMMENT_START Hello World $BLOCK_COMMENT_END\"\n    }\n} 更多关于代码片段的信息 Visual Studio Code 的官方文档 。"}, {"title": "README 文档结构", "path": "posts/2024/README_outline.html", "tags": ["GitHub"], "content": "README 文档结构 Foobar （项目名称） Foobar is a Python library for dealing with word pluralization.（项目简介） Installation（安装） Use the package manager pip to install foobar. pip install foobar Usage（使用） import foobar\n## returns 'words'\nfoobar.pluralize('word')\n## returns 'geese'\nfoobar.pluralize('goose')\n## returns 'phenomenon'\nfoobar.singularize('phenomena') Contributing（如何贡献） Pull requests are welcome. For major changes, please open an issue first to discuss what you would like to change. Please make sure to update tests as appropriate. License（许可证） MIT"}, {"title": "lazy.nvim 学习笔记", "path": "posts/2024/lazy.nvim_note.html", "tags": ["vim", "lazy.nvim"], "content": "lazy.nvim 学习笔记 两个命令，三个路径，两个命令是拉取 lazy.nvim 和拉取 init.lua 配置文件命令，三个路径是 lazy.nvim 的路径、init.lua 的路径和 Neovim 插件的路径 步骤： 第一个命令，拉取 lazy.nvim git clone https://github.com/folke/lazy.nvim.git C:\\Users\\24109\\AppData\\Local\\nvim-data\\site\\pack\\packer\\start\\lazy.nvim 第二个命令，拉取 init.lua 配置文件 git clone https://gitee.com/sr1122/nvim.git C:\\Users\\24109\\AppData\\Local\\nvim 下载插件 打开 Neovim，lazy.nvim 会自动下载插件，下载完成后，重启 Neovim 第一个路径，lazy.nvim 路径 C:\\Users\\admin\\AppData\\Local\\nvim-data\\site\\pack\\packer\\start\\lazy.nvim 第二个路径，init.lua 配置文件路径 C:\\Users\\24109\\AppData\\Local\\nvim 第三个路径，Neovim 插件路径 C:\\Users\\admin\\AppData\\Local\\nvim-data\\lazy 这个里面放的就是你的插件"}, {"title": "git commit message 规范", "path": "posts/2024/git_commit_message_standard.html", "tags": ["git"], "content": "git commit message 规范 在 Git 中，提交信息的规范非常重要，因为它可以帮助其他开发者了解每次提交的目的。以下是一种常见的提交信息规范： type : 提交的类型，例如：feat(新功能)、fix(修复 bug)、docs(文档改变)、style(格式或者结构改变)、refactor(代码重构)、test(测试代码)、chore(构建过程或辅助工具的变动)。 scope : 表示影响的范围，例如：数据层、控制层、视图层等。 subject : 提交的简短描述。 body : 提交的详细描述，可以分为多行。 footer : 关联的问题编号，例如： #123 , #456 。 以下是一个示例： feat(user): add login function\n\nThis commit adds a new login function to the user module. The function takes a username and password and checks them against the database.\n\nRelated to #123, #456 在命令行中，你可以使用以下命令进行提交： git commit -m \"feat(user): add login function\" -m \"This commit adds a new login function to the user module. The function takes a username and password and checks them against the database.\" -m \"Related to #123, #456\" 这种规范可以帮助你和你的团队更好地理解每次提交的目的和影响。"}, {"title": "VSCode 高效使用指南", "path": "posts/2024/vscode_note.html", "tags": ["vscode"], "content": "VSCode 高效使用指南 🔑 SSH 连接服务器配置 生成密钥对 ：本地执行 ssh-keygen ，公钥路径 C:\\Users\\用户\\.ssh\\id_rsa.pub 配置服务器 ： # 服务器操作\necho 公钥内容 >> ~/.ssh/authorized_keys\nsudo passwd 用户名  # 重置密码 本地配置 ~/.ssh/config ： Host 服务器hostname  # 通过 hostname 命令获取\nHostName 服务器IP\nUser 用户名 💡 提示：密钥认证可免密操作，首次连接需输入密码验证身份 🛠️ VSCodium 扩展源切换 修改 安装根目录/resources/app/product.json 文件中的 extensionsGallery 键对应的值如下： \"extensionsGallery\": {\n    \"serviceUrl\": \"https://marketplace.visualstudio.com/_apis/public/gallery\",\n    \"itemUrl\": \"https://marketplace.visualstudio.com/items\"\n} ✨ 高效编辑技巧 多光标操作 Alt+单击 ：任意位置添加光标 Ctrl+F2 ：全选相同内容添加光标 Alt+↑/↓ ：整行快速复制 批量注释 Ctrl+/ ：选中多行后切换注释状态（Mac： Cmd+/ ） 查找替换 Ctrl+F ：快速查找 Ctrl+H ：替换当前文件内容 Ctrl+Alt+Enter ：全部替换 ⚠️ 注意事项 代码片段（snippets）在以下场景不生效： Markdown 数学公式块（ $$ 包裹区域） YAML 文档属性区块"}, {"title": "python 学习笔记", "path": "posts/2024/python_note.html", "tags": ["python"], "content": "python 学习笔记 pip.ini 配置 C:\\Users\\admin\\AppData\\Roaming\\pip\\pip.ini [global]\ntarget = D:\\Python\\Python312\\Lib\\site-packages\nindex-url = https://pypi.tuna.tsinghua.edu.cn/simple\ncache-dir = D:\\python\\pip-cache python 列出依赖库 pip freeze > requirements.txt uv pip freeze > requirements.txt 根据依赖文件卸载第三方库 pip uninstall -r requirements.txt -y 使用 uv uv pip uninstall -r requirements.txt -y 创建和使用虚拟环境 ## 创建虚拟环境\npython -m venv venv\n\n## 使用 uv\nuv venv\n\n## 激活虚拟环境\n.\\venv\\Scripts\\activate  ## Windows\n## 或者\nsource venv/bin/activate  ## macOS 和 Linux\n\n## 安装第三方库\npip install requests\n\n## 使用 uv\nuv pip install requests\n\n## 卸载第三方库\npip uninstall requests\n\n## 使用 uv\nuv pip uninstall requests\n\n## 生成依赖文件\npip freeze > requirements.txt\n\n## 使用 uv\nuv pip freeze > requirements.txt\n\n## 根据依赖文件下载第三方库\npip install -r requirements.txt\n\n## 使用 uv\nuv pip install -r requirements.txt\n\n## 根据依赖文件卸载第三方库\npip uninstall -r requirements.txt -y\n\n## 使用 uv\nuv pip uninstall -r requirements.txt -y\n\n## 停用虚拟环境\ndeactivate python pip 换源 清华源： pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple 查看源 pip config list 输出： global.index-url='https://pypi.tuna.tsinghua.edu.cn/simple' 恢复默认源： pip config unset global.index-url 修改 pip 安装的第三方库位置 在 C:\\Users\\admin\\AppData\\Roaming\\pip\\pip.ini 中写入 [global]\ntarget = D:\\Python\\Python312\\Lib\\site-packages 查看第三方库的位置 python -m site uv python -m site 查看指定库的详细信息 pip show requests uv pip show requests Name: requests\nVersion: 2.25.1\nSummary: Python HTTP for Humans.\nHome-page: https://requests.readthedocs.io\nAuthor: Kenneth Reitz\nAuthor-email: me@kennethreitz.org\nLicense: Apache 2.0\nLocation: /path/to/your/env/lib/python3.8/site-packages\nRequires: certifi, chardet, idna, urllib3\nRequired-by: 查看 Python 已安装的第三方库 pip list uv pip list 功能 uv 命令 pip 命令 永久修改方式 查找缓存 uv cache dir pip cache dir - 清理缓存 uv cache clean pip cache purge - 修改位置 环境变量 UV_CACHE_DIR 环境变量 PIP_CACHE_DIR 或 配置文件 pip.ini uv cache 查看 uv cache 的位置 uv cache dir 删除 uv cache uv cache clean 修改 uv cache dir [System.Environment]::SetEnv"}, {"title": "vitepress 学习笔记", "path": "posts/2024/vitepress_note.html", "tags": ["vitepress"], "content": "vitepress 学习笔记 我的 vitepress 目录结构是 .\n├─ .vitepress # vitepress 配置文件夹\n│  ├─ theme # 自定义主题\n│  │  └─ index.ts\n│  │  └─ style.css\n│  └─ config.mts # viepress 配置文件\n├─ cache # 缓存文件\n├─ html # 生成的静态文件\n├─ mkdocs # viepress 源文件夹\n│  ├─ public # 图片等文件\n│  └─ index.md # 首页\n└─ package-lock.json\n└─ package.json 步骤： https://vitepress.dev/zh/guide/getting-started 第一步，下载 vitepress 包 npm add -D vitepress 第二步，初始化 vitepress 项目 npx vitepress init 这一步的输出如下 ┌  Welcome to VitePress!\n│\n◇  Where should VitePress initialize the config? # 这里选择根目录\n│  ./ # [!code highlight]\n│\n◇  Site title: # confid.mts 的 title 字段\n│  My Awesome Project # [!code highlight]\n│\n◇  Site description: # confid.mts 的 description 字段\n│  A VitePress Site # [!code highlight]\n│\n◇  Theme: # 这里选默认主题 + 自定义主题\n│  Default Theme + Customization # [!code highlight]\n│\n◇  Use TypeScript for config and theme files? # 选 TypeScript 为配置文件\n│  Yes # [!code highlight]\n│\n◇  Add VitePress npm scripts to package.json? #不要在 package.json 中添加脚本\n│  No # [!code highlight]\n│\n└  You're all set! Now run npx vitepress dev and start writing. 第三步，修改 vitepress 配置文件 // .vitepress/config.mts\nexport default(\n  defineConfig({\n    srcDir: 'mkdocs', // 这里面存放的是 markdown 文件 // [!code ++]\n    outDir: 'html', // 这里面存放的是生成的静态文件 // [!code ++]\n    cacheDir: 'cache', // 这里面存放的是缓存文件 // [!code ++]\n  })\n) 第四步，预览和构建站点 预览站点 npx vitepress dev 构建站点 npx vitepress build 预览构建好的站点 npx vitepress preview vitepress 维护指南 每次更新 vitepress 文档，都需要执行以下步骤 运行 tags.py 和 categories.py 更新 tags.md 和 categories.md 文件（每次） 更新仓库根目录下的 README.md 文件（每次） 更新 config.mts 的 siderbar 链接（每次） 每次更新 vitepress 文档，至少有 5 个 git 变动 每个月还得更新 index.md 的 features 列表（每月） 每年都要更新 config.mts 的 nav 字段（每年）"}, {"title": "个人自用软件", "path": "posts/2024/personal_software.html", "tags": ["Windows", "Android"], "content": "个人自用软件 Android simple_live https://github.com/xiaoyaocz/dart_simple_live pilipala https://github.com/guozhigq/pilipala Hydrogen https://github.com/huajiqaq/Hydrogen Aegis https://github.com/beemdevelopment/Aegis Localsend https://github.com/localsend/localsend KeePassDX https://github.com/Kunzisoft/KeePassDX Windows vscode https://code.visualstudio.com/ FileConverter https://github.com/Tichau/FileConverter SteamTools https://github.com/BeyondDimension/SteamTools Localsend https://github.com/localsend/localsend KeePassXC https://github.com/keepassxreboot/keepassxc gpg4win https://www.gpg4win.org git https://git-scm.com git-crypt https://github.com/AGWA/git-crypt"}, {"title": "Typst 笔记", "path": "posts/2024/Typst_note.html", "tags": ["Typst"], "content": "Typst 笔记 Tyspt 官方文档 导出命令 PDF（默认格式） typst c input.typ typst c input.typ --pages 1-3  # 仅导出第1-3页 PNG typst c input.typ output.png 多页时必须加上 \"png-{0p}.png\" 参数，这个参数为导出的文件命令 {0p} 会补零， {p} 不会补零，推荐使用 {0p} ，在文件管理器中，补零格式（01, 02...）的排序永远比自然数字（1, 2...）更可靠 可通过 --ppi 调整分辨率（默认 144 PPI） typst c input.typ \"png-{0p}.png\" --ppi 300  # 300 DPI，补零页码 {t} 参数是总页数 typst c main.typ \"page-{0p}-of-{t}.png\" SVG typst c input.typ output.svg 多页时必须加上 \"png-{0p}.png\" 参数，这个参数为导出的文件命令 {0p} 会补零， {p} 不会补零，推荐使用 {0p} ，在文件管理器中，补零格式（01, 02...）的排序永远比自然数字（1, 2...）更可靠 typst c input.typ \"svg-{0p}.svg\" --pages 2,4-6  # 导出第 2、4、5、6 页 {t} 参数是总页数 typst c main.typ \"page-{0p}-of-{t}.svg\" HTML（实验性功能） typst c --features html input.typ output.html 部分语法 标题 = 第一级大标题\n== 第二级大标题 无序列表 - 无序列表 有序列表 1. 有序列表\n+ 有序列表 加重字体 *加重字体* 斜体 _斜体_ 字体 全局： #set text(font: \"kaiti\", fill: red, size: 12pt)\n大小为12磅，字体为楷体的红色内容 局部： #text(font: \"kaiti\", fill: red, size: 12pt)[大小为12磅，字体为楷体的红色内容] 位置 全局： #set align(left)\n居左 局部： #align(left)[居左] 下划线 #underline[此处有下划线] 上划线 #overline[此处有上划线] 上标 #super[这里是上标内容] 下标 #sub[这里是下标内容] 删除线 #strike[被删除的内容] 高亮 #highlight[高亮内容] 链接 #link(\"https://baidu.com\")[百度] 字间距 & 行间距 #set par(leading: 18pt) //行间距\n#set text(tracking: 0.1pt) //字间距 文档属性 #set document(\n  title: title,\n  author: author,\n  keywords: str,array,\n  date: none, auto,datetime,\n) 页边距 #set page(margin: (\n    top: 2.54cm, //上边距\n    bottom: 2.54cm, //下边距\n    right: 2.54cm, //右边距\n    left: 2.54cm, //左边距\n  )) 水印 #set page(background: rotate(45deg,\n  text(50pt, fill: rgb(\"FFCBC4\"))[\n    *这是水印*\n  ]\n)) 引用 #set quote(block: true) //开启引用块\n\n#quote(attribution: [引用文本的来源])[\n  引用的文本\n] 大纲 #outline() 手动分页 #pagebreak() 插入图片 #image(\"4.jpeg\") #figure(\n    image(\"图片路径\", width: 10pt),\n    caption: \"说明\"\n)"}, {"title": "B站嵌入代码", "path": "posts/2024/bilibili_embedding_code.html", "tags": ["B站"], "content": "B站嵌入代码 正常显示 在 <iframe src=\"//player.bilibili.com 之中添加 https: 变成 <iframe src=\"https://player.bilibili.com 修改屏幕尺寸 style=\"width:100%;aspect-ratio:16/9;\" <iframe src=\"//player.bilibili.com/player.html?aid=425938140&bvid=BV1G3411M7BN&cid=584177306&p=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" style=\"width:100%;aspect-ratio:16/9;\"></iframe> 禁止自动播放 如果不修改代码，会在打开文章页面的时候，视频就会直接自动从头开始播放，突然的声音可能带来不必要的惊吓，并且会让访问者错过开头，显得很突兀。 要取消自动播放，只需在视频 src=url 链接最后加上：&autoplay=0 <iframe src=\"//player.bilibili.com/player.html?aid=425938140&bvid=BV1G3411M7BN&cid=584177306&p=1&autoplay=0\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\"></iframe> 更多B站嵌入代码修改 如果要更改更多B站视频嵌入代码设置选项，可以参考下面关于iframe引用的B站官方参数设置。 设置方法就是在src=url链接后面添加:&参数名=参数数值 比如弹幕关闭：&danmaku=0，以此类推 参数名 参数用途 使用方法 autoplay 是否自动播放(默认否) 1: 开启, 0: 关闭 danmaku 默认弹幕开关(默认开启) 1: 开启, 0: 关闭 muted 是否默认静音(默认否) 1: 开启, 0: 关闭 hasMuteButton 一键静音按钮是否显示（默认不显示） 1: 开启, 0: 关闭 hideCoverInfo 视频封面下方是都显示播放量弹幕量等信息(默认显示) 1: 开启, 0: 关闭 hideDanmakuButton 是否隐藏弹幕按钮（默认不隐藏） 1: 开启, 0: 关闭 noFullScreenButton 是否隐藏全屏按钮(默认显示) 1: 开启, 0: 关闭 fjw 是否开始记忆播放(默认开启) 1: 开启, 0: 关闭 t 默认开始时间(默认0) 直接填写数值，单位秒"}, {"title": "Vim 高效速查笔记", "path": "posts/2024/vim_note.html", "tags": ["vim"], "content": "Vim 高效速查笔记 核心模式（ESC切换普通模式） 模式 进入方式 状态栏提示 核心用途 普通模式 默认/按 ESC 或 jj - 导航/执行命令 插入模式 i I a A o O s S INSERT 文本编辑 命令模式 : 或 / 命令行输入区 执行复杂命令 可视模式 v V Ctrl+v VISUAL 文本块选择 推荐配置： .vimrc 添加 inoremap jj <Esc> 用 jj 替代ESC 高效操作体系 ▶ 文件操作 vim file1                 # 打开单个文件\nvim -O2 file1 file2       # 左右分屏打开两个文件\n:sp filename              # 上下分屏打开新文件\nCtrl+w → ← ↑ ↓            # 分屏间跳转方向键\n:q!                       # 强制退出不保存\n:wq                       # 保存并退出\nZZ                        # 快速保存退出（普通模式） ▶ 光标移动（普通模式） h/j/k/l       ←/↓/↑/→\nw/e          下个单词首/尾\n0/$          行首/行尾\ngg/G         文件首/尾\nCtrl+f/b     下/上翻页\n20G          跳转第20行 ▶ 编辑神技 ddp         交换当前行与下一行\nyyp         复制当前行\nci\"         快速修改引号内容\ndt)         删除到右括号前\nguu/gUU     当前行全小/大写\n>%          缩进当前代码块 ▶ 搜索替换 /pattern    正向搜索（n/N跳转）\n?pattern    反向搜索\n:%s/old/new/gc   全局替换带确认\n:'<,'>s/old/new  选区替换（可视模式选择后） ▶ 分屏管理 Ctrl+w v    垂直分屏\nCtrl+w s    水平分屏\nCtrl+w q    关闭当前分屏\nCtrl+w o    仅保留当前分屏 高频命令速查表 文本操作（普通模式） 命令 功能 示例 x 删除当前字符 3x 删3字符 dw 删至词尾 d2w 删2词 D 删至行尾 p 粘贴 \"+p 粘贴系统剪贴板 . 重复上次操作 可视模式 v       字符选择模式\nV       行选择模式\nCtrl+v  块选择模式\ny       复制选中区域\nd       删除选中区域\ngv      重选上次选区 宏录制 qa      开始录制宏a\nq       停止录制\n@a      执行宏a\n100@a   执行100次\n:reg    查看所有宏 高阶技巧 多文件操作 :ls             查看打开文件列表\n:b2             切换至第2个文件\n:bd             关闭当前文件\n:args *.txt     批量打开txt文件 代码折叠 zc      折叠当前代码块\nzo      展开折叠\nzR      展开所有折叠\nzm      增加折叠层级 插件推荐 NERDTree - 文件树导航 vim-airline - 状态栏美化 coc.nvim - 智能补全 附： vimtutor 命令可启动官方30分钟交互教程"}, {"title": "git-sizer 学习笔记", "path": "posts/2024/git-izer_note.html", "tags": ["git"], "content": "git-sizer 学习笔记 git-sizer 命令输出 $ git-sizer --verbose\n\nProcessing blobs: 1215\nProcessing trees: 1086\nProcessing commits: 513\nMatching commits to trees: 513\nProcessing annotated tags: 0\nProcessing references: 2\n| Name                         | Value     | Level of concern               |\n| ---------------------------- | --------- | ------------------------------ |\n| Overall repository size      |           |                                |\n| * Commits                    |           |                                |\n|   * Count                    |   513     |                                |\n|   * Total size               |   148 KiB |                                |\n| * Trees                      |           |                                |\n|   * Count                    |  1.09 k   |                                |\n|   * Total size               |  1.34 MiB |                                |\n|   * Total tree entries       |  29.7 k   |                                |\n| * Blobs                      |           |                                |\n|   * Count                    |  1.22 k   |                                |\n|   * Total size               |  26.4 MiB |                                |\n| * Annotated tags             |           |                                |\n|   * Count                    |     0     |                                |\n| * References                 |           |                                |\n|   * Count                    |     2     |                                |\n|     * Branches               |     1     |                                |\n|     * Remote-tracking refs   |     1     |                                |\n|                              |           |                                |\n| Biggest objects              |           |                                |\n| * Commits                    |           |                                |\n|   * Maximum size         [1] |  1.97 KiB |                                "}, {"title": "LaTeX 与希腊字母对照表", "path": "posts/2024/LaTeX_note.html", "tags": ["LaTeX"], "content": "LaTeX 与希腊字母对照表 小写字母 大写字母 英文 小写 LaTeX 公式 小写 LaTeX 形式效果 大写 LaTeX 公式 大写 LaTeX 形式效果 α Α Alpha $\\alpha$ α \\alpha α $\\Alpha$ A \\Alpha A β Β Beta $\\beta$ β \\beta β $\\Beta$ B \\Beta B γ Γ Gamma $\\gamma$ γ \\gamma γ $\\Gamma$ Γ \\Gamma Γ δ Δ Delta $\\delta$ δ \\delta δ $\\Delta$ Δ \\Delta Δ ε, ϵ Ε Epsilon $\\varepsilon$ , $\\epsilon$ ε \\varepsilon ε, ϵ \\epsilon ϵ $\\Epsilon$ E \\Epsilon E ζ Ζ Zeta $\\zeta$ ζ \\zeta ζ $\\Zeta$ Z \\Zeta Z η Η Eta $\\eta$ η \\eta η $\\Eta$ H \\Eta H θ Θ Theta $\\theta$ θ \\theta θ $\\Theta$ Θ \\Theta Θ ι Ι Iota $\\iota$ ι \\iota ι $\\Iota$ I \\Iota I κ Κ Kappa $\\kappa$ κ \\kappa κ $\\Kappa$ K \\Kappa K λ Λ Lambda $\\lambda$ λ \\lambda λ $\\Lambda$ Λ \\Lambda Λ μ Μ Mu $\\mu$ μ \\mu μ $\\Mu$ M \\Mu M ν Ν Nu $\\nu$ ν \\nu ν $\\Nu$ N \\Nu N ξ Ξ Xi $\\xi$ ξ \\xi ξ $\\Xi$ Ξ \\Xi Ξ ο Ο Omicron $\\omicron$ ο \\omicron ο $\\Omicron$ O \\Omicron O π ∏ Pi $\\pi$ π \\pi π $\\Pi$ Π \\Pi Π ρ Ρ Rho $\\rho$ ρ \\rho ρ $\\Rho$ P \\Rho P σ, ς ∑ Sigma $\\sigma$ ， $\\varsigma$ σ \\sigma σ, ς \\varsigma ς $\\Sigma$ Σ \\Sigma Σ τ Τ Tau $\\tau$ τ \\tau τ $\\Tau$ T \\Tau T υ Υ Upsilon $\\upsilon$ υ \\upsilon υ $\\Upsilon$ Υ \\Upsilon Υ φ, ϕ Φ Phi $\\varphi$ , $\\phi$ φ \\varphi φ, ϕ \\phi ϕ $\\Phi$ Φ \\Phi Φ χ Χ Chi $\\chi$ χ \\chi χ $\\Chi$ X \\Chi X ψ Ψ Psi $\\psi$ ψ \\psi ψ $\\Psi$ Ψ \\Psi Ψ ω Ω Omega $\\omega$ ω \\omega ω $\\Omega$ Ω \\Omega Ω"}, {"title": "git 重置当前分支", "path": "posts/2024/git_reset.html", "tags": ["git"], "content": "git 重置当前分支 git reset 命令用于重置当前分支的 HEAD 到指定的状态。以下是一些常用的 git reset 命令： 1. 软重置（保留工作目录和暂存区的更改）： git reset --soft <commit> 2. 混合重置（保留工作目录的更改，但重置暂存区）： git reset --mixed <commit> 这是默认选项，如果不指定参数， git reset 会默认使用 --mixed 。 3. 硬重置（丢弃工作目录和暂存区的更改）： git reset --hard <commit> 其中 <commit> 是你想重置到的提交的哈希值。如果你想重置到上一个提交，可以使用 HEAD^ 代替 <commit> 。例如： git reset --hard HEAD^"}, {"title": "用 you-get 下载B站视频", "path": "posts/2024/you-get_note.html", "tags": ["python", "B站"], "content": "用 you-get 下载B站视频 1. 拉取 you-get pip install you-get 2. 获取B站 cookies 在 edge 浏览器下载 Cookie-Editor 扩展，然后打开 B站 ，通过 Cookie-Editor 导出B站的 cookie 导出格式要为 Netscape 格式，因为 you-get 目前只支持 Mozilla 的 cookies.sqlite 和 Netscape 的 cookies.txt 两种格式的 cookies，所以我们需要导出符合格式的 cookies 3. 下载视频 把保存好的 cookies.txt 放到你所执行命令的目录下，然后执行 you-get --cookies=cookies.txt \"https://www.bilibili.com/video/BVxxxxxx\" 命令 you-get 会默认下载最高清晰度 就 ok 了"}, {"title": "ffmpeg 自用命令", "path": "posts/2024/ffmpeg_note.html", "tags": ["ffmpeg"], "content": "ffmpeg 自用命令 下载链接： ffmpeg 初学者用户建议选择 ffmpeg-git-essentials.7z 查看视频一共有多少帧数 ffprobe -v error -select_streams v:0 -show_entries stream=nb_frames -of default=nokey=1:noprint_wrappers=1 your_video_file.mp4 提升视频锐度 ffmpeg -i input.mp4 -vf \"unsharp\" output.mp4 提升视频分辨率 ffmpeg -i input.mp4 -vf \"scale=3840:2160\" output.mp4 查看视频分辨率 ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 video.mp4 查看视频元数据 ffprobe -v quiet -print_format json -show_format your_video_file.mp4 把多个视频合并为一个视频 file 'input3.mp4'\nfile 'input1.mp4'\nfile 'input2.mp4' 把这个 txt 文件和待处理的视频放到同一文件夹下， ffmpeg 会按照从上倒下的顺序合并视频 然后，你可以使用以下命令合并视频： ffmpeg -f concat -safe 0 -i files.txt -c copy output.mp4 视频转换为不同的格式 ffmpeg -i input.mp4 output.avi 剪切视频 ffmpeg -i input.mp4 -ss 00:00:30 -t 00:00:10 -c:v libx264 -c:a aac output.mp4 使用 ffmpeg 剪切视频，你可以使用 -ss 选项来指定开始时间，使用 -t 选项来指定持续时间。例如，如果你想从视频的第 30 秒开始，剪切 10 秒的视频，你可以使用以上命令 -c copy 指定了将原始数据流复制到输出文件，而不进行任何重新编码（用 -c copy 剪切的视频不会将视频重新编码，这种方式速度非常快，但可能会导致一些问题，因为它可能会在非关键帧（I帧）的位置切割视频，导致切割出来的视频在开始的一段时间内无法正常播放。所以我们用以上新的命令） 注意，时间可以用时:分:秒的格式指定，也可以直接用秒数指定。例如， 00:01:30 和 90 都表示 1 分 30 秒。 把音频从视频中分离出来 ffmpeg -i input.mp4 -vn output.aac 在这里， input.mp4 是你的输入文件， -vn 选项禁用了视频流， output.aac 是输出的音频文件。 禁用音频，把视频文件分离出来 ffmpeg -i input.mp4 -an output.mp4 在这里， input.mp4 是你的输入文件， -an 选项禁用了音频流， output.mp4 是输出的视频文件。 改变音频格式 ffmpeg -i input.mp3 output.aac 调整视频的分辨率 ffmpeg -i input.mp4 -vf \"scale=1280:720\" output.mp4 在这里， input.mp4 是你的输入文件， scale=1280:720 是一个过滤器，用于将视频的分辨率调整为 1280x720 ， output.mp4 是输出文件。 添加视频水印 ffmpeg -i input.mp4 -i watermark.png -filter_complex \"overlay=W-w-10:H-h-10\" output.mp4 在这里， input.mp4 是你的输入视频文件， watermark.png 是你的水印图片， overlay=W-w-10:H-h-10 是一个过滤器，它将水印图片放在视频的右下角，离边缘 10 像素， output.mp4 是输出文件。 注意， W 和 H 分别代表视频的宽度和高度， w 和 h 分别代表水印的宽度和高度。你可以调整这些值来改变水印的位置。 转码视频 ffmpeg -i input.mp4 -b:v 1000k -b:a 128k output.mp4 input.mp4 是你的输入视频文件， 1000k 是视频比特率， 128k 是音频比特率， output.mp4 是输出文件。 倒放视频 ffmpeg -i input.mp4 -vf \"reverse\" output.mp4 input.mp4 是你的输入文件， -vf \"reverse\" 选项将视频流倒"}, {"title": "Linux 学习笔记", "path": "posts/2024/Linux_note.html", "tags": ["Linux"], "content": "Linux 核心速查指南 文件系统结构 graph LR\n  / --> |\"bin\"| Bin[二进制可执行文件]\n  / --> |\"boot\"| Boot[启动加载器文件]\n  / --> |\"dev\"| Dev[设备文件]\n  / --> |\"etc\"| Etc[配置文件]\n  / --> |\"home\"| Home[用户主目录]\n  / --> |\"lib\"| Lib[共享库文件]\n  / --> |\"media\"| Media[可移除媒体]\n  / --> |\"mnt\"| Mnt[临时挂载点]\n  / --> |\"opt\"| Opt[可选的应用软件包]\n  / --> |\"proc\"| Proc[进程信息虚拟文件系统]\n  / --> |\"root\"| RootDir[超级用户的主目录]\n  / --> |\"run\"| Run[运行时数据]\n  / --> |\"sbin\"| Sbin[系统管理二进制可执行文件]\n  / --> |\"srv\"| Srv[服务数据]\n  / --> |\"sys\"| Sys[设备和系统信息]\n  / --> |\"tmp\"| Tmp[临时文件]\n  / --> |\"usr\"| Usr[用户程序和数据]\n  / --> |\"var\"| Var[可变数据] 目录 描述 /bin 二进制可执行文件（命令），通常没有子目录 /boot 包含 GRUB 启动加载器配置和内核文件 /dev 设备文件（如 sda 硬盘、 tty 终端） /etc 系统配置文件（如 apache2 服务器配置、 ssh 配置） /home 用户主目录，按用户名创建子目录 /lib 共享库文件（如 systemd 系统服务库） /media 自动挂载可移动媒体设备（如 USB） /mnt 手动挂载临时文件系统的挂载点 /opt 第三方应用软件安装目录，按软件名创建子目录 /proc 虚拟文件系统，提供内核和进程状态信息 /root root 用户专属主目录 /sbin 系统管理命令，通常没有子目录 /srv 服务数据目录，结构根据服务器应用需求变化 /sys 虚拟文件系统，提供设备和驱动配置接口 /tmp 临时文件，系统重启自动清空 /usr 用户程序资源，包含 bin （用户命令）、 lib （用户库）、 share （共享数据）等子目录 /var 可变数据，包含 log （日志）、 mail （邮件）、 www （网页）等子目录 高频命令速查 文件操作 ls -alh           # 详细列表（含隐藏文件）\ncp -r dir1 dir2   # 递归复制目录\nmv old new        # 移动/重命名\nrm -rf dir        # 强制递归删除（慎用！）\nfind / -name \"*.log\"  # 全局文件搜索 文本处理 cat file | grep \"pattern\"    # 文本过滤\nhead -n 20 file              # 显示前20行\ntail -f /var/log/syslog      # 实时追踪日志\nvim file                     # 编辑文件（:wq保存退出） 系统管理 sudo !!            # 用sudo执行上条命令\nps aux | grep nginx# 进程搜索\nkill -9 PID        # 强制终止进程\ndf -h              # 磁盘空间查看\nfree -m            # 内存使用情况 网络相关 curl -I example.com  # 查看HTTP头\nnetstat -tulpn       # 查看开放端口\nssh user@host -p22   # SSH连接\nscp file user@host:/path  # 安全传输 包管理（Debian系） apt update          # 更新源列表\napt install package # 安装软件\napt remove --purge package  # 彻底卸载\ndpkg -l | grep nginx# 查询已安装包 权限管理速记 chmod 755 script.sh  # 设置权限：rwxr-xr-x\nchown user:group file # 修改所有者\numask 022            # 新建文件默认权限 系统服务管理 systemctl start nginx    # 启动服务\nsystemctl enable nginx   # 设置开机启动\njournalctl -u nginx -f   # 查看服务日志 快捷键备忘 组合键 功能 Ctrl+"}, {"title": "GPG 在通信中的简单理解", "path": "posts/2024/gpg_communication.html", "tags": ["GPG", "加密"], "content": "GPG 在通信中的简单理解 +----------------+          +----------------+\n| Alice生成密钥对 |          | Bob生成密钥对  |\n| 公钥A | 私钥A   |          | 公钥B | 私钥B  |\n+-------+--------+          +-------+--------+\n        | 交换公钥 |                    |\n        +--------->+<------------------+\n                   |\n+------------------|-------------------+\n| 加密阶段：        | 解密阶段：         |\n| Alice用公钥B加密  → 密文 → Bob用私钥B解密 |\n+------------------|-------------------+\n| 签名阶段：         | 验证阶段：         |\n| Alice用私钥A签名 → 签名 → Bob用公钥A验证 |\n+--------------------------------------+ 核心概念 非对称加密体系 ： 公钥（Public Key）：可公开分发的加密钥匙 私钥（Private Key）：必须严格保密的解密钥匙 数学关系：公钥由私钥推导得出，但无法逆向反推 数字签名三要素 ： 身份认证（Authentication） - 确认消息来源 完整性验证（Integrity） - 确保内容未被篡改 不可否认性（Non-repudiation） - 发送方无法否认发送行为 密钥管理流程 # 生成密钥对（4096位 RSA）\ngpg --full-generate-key\n\n# 导出公钥\ngpg --armor --export alice@example.com > alice_pubkey.asc\n\n# 导入他人公钥\ngpg --import bob_pubkey.asc\n\n# 查看密钥列表\ngpg --list-keys 完整通信流程（Alice → Bob） 准备阶段 双方生成密钥对 交换公钥（通过密钥服务器/邮件/当面交换） 互相签名验证公钥真实性 加密阶段 Alice 撰写原始消息 message.txt 使用 Bob 的公钥加密： gpg --encrypt --recipient bob@example.com message.txt 生成数字签名： gpg --sign --detach-sig message.txt.gpg 解密验证阶段 Bob 接收加密文件 message.txt.gpg 和签名文件 message.sig 验证签名： gpg --verify message.sig message.txt.gpg 解密文件： gpg --decrypt message.txt.gpg > decrypted_message.txt 安全机制解析 步骤 使用密钥 数学运算 安全目标 消息加密 Bob 的公钥 RSA 加密 机密性 生成哈希值 SHA-256 哈希计算 完整性校验 签名加密 Alice 的私钥 RSA 加密 身份认证/不可否认性 签名验证 Alice 的公钥 RSA 解密 验证来源 消息解密 Bob 的私钥 RSA 解密 获取明文 典型应用场景 安全电子邮件（Thunderbird + Enigmail） 软件包签名验证（Linux 软件源） Git commit 签名 加密文件存储 SSH 认证（GPG 作为 SSH 密钥） 常见问题解答 Q：私钥泄露怎么办？\nA：立即吊销密钥并重新生成： gpg --gen-revoke [key-id] Q：如何验证公钥真实性？\nA：通过指纹校验（16位短指纹更易验证）： gpg --fingerprint bob@example.com Q：为什么需要交叉签名？\nA：建立信任链，推荐做法： 当面交换密钥指纹 参加密钥签名聚会（Key Signing Party） 使用 Web of Trust 信任网络 Q：GPG 与对称加密的区别？\nA：对比表 特性 GPG（非对称） AES（对称） 密钥数量 密钥对（2个） 单一密钥 加密速度 慢（适合小数据） 快（适合大数据） 密钥交换 无需安全通道 需要安全通道 典型用途 数字签名/密钥交换 文件加密 下载 gpg4win | GPG 官方手册"}, {"title": "git 分支操作", "path": "posts/2024/git_branch.html", "tags": ["git"], "content": "git 分支操作 我使用 git checkout 命令回溯到之前的某个提交，我该如何把仓库彻底固定在当前提交 如果你想要将仓库彻底固定在当前提交，你可以创建一个新的分支。这样，你就可以在这个新的分支上进行工作，而不会影响到主分支。以下是如何创建新分支的命令： git branch new_branch_name\ngit checkout new_branch_name 这两行命令首先创建了一个名为 \"new_branch_name\" 的新分支，然后切换到这个新分支。你需要将 \"new_branch_name\" 替换为你想要的分支名。 如何在 Git 中删除一个分支？ 在 Git 中，你可以使用以下命令来删除一个分支： git branch -d branch_name 这个命令会删除名为 \"branch_name\" 的分支。你需要将 \"branch_name\" 替换为你想要删除的分支名。 如果你想要强制删除一个分支，即使它还没有被合并，你可以使用 -D 选项： git branch -D branch_name 请注意，这个操作是不可逆的，所以在执行之前请确保你真的想要删除这个分支。 我该如何删除远程分支 在 Git 中，你可以使用以下命令来删除一个远程分支： git push origin --delete branch_name 这个命令会删除名为 \"branch_name\" 的远程分支。你需要将 \"branch_name\" 替换为你想要删除的远程分支名。 请注意，这个操作是不可逆的，所以在执行之前请确保你真的想要删除这个远程分支。 重命名分支 在 Git 中，你可以使用以下命令来重命名一个分支： git branch -m old_branch_name new_branch_name 这个命令会将名为 \"old_branch_name\" 的分支重命名为 \"new_branch_name\"。你需要将 \"old_branch_name\" 和 \"new_branch_name\" 替换为你想要的分支名。 如果你当前已经在 \"old_branch_name\" 分支上，你可以省略 \"old_branch_name\"，直接使用以下命令： git branch -m new_branch_name 把本地的 main 分支与远程 main 分支绑定 git branch --set-upstream-to=origin/main main 如何把一个本地分支与一个远程分支建立联系 你可以使用 git branch --set-upstream-to 命令来将一个本地分支与一个远程分支建立联系。这个命令会设置远程分支为本地分支的上游分支。 以下是具体的命令： git branch --set-upstream-to=<remote>/<branch> <local-branch> 这里的 <remote> 是远程仓库的名字， <branch> 是远程分支的名字， <local-branch> 是本地分支的名字。 例如，如果你想将本地的 master 分支与 origin 远程仓库的 master 分支建立联系，你可以使用以下命令： git branch --set-upstream-to=origin/master master 设置上游分支后，你可以使用 git pull 和 git push 命令来拉取和推送更改，而不需要每次都指定远程仓库和分支的名字。"}, {"title": "神秘博士复活时间表", "path": "posts/2024/former_doctor_who.html", "tags": ["神秘博士"], "content": "神秘博士复活时间表 第一任博士是在老版第三季的《第十行星》中重生的，这个视频资料已经丢失了只能在哔哩哔哩动画上找到重生瞬间。重生原因是因为博士要毁灭赛博人母星，结果能量超载损害了博士的健康从而重生。 第二任博士是在老版的《战争游戏》一集，重生的资料应该也丢失了，至少我是没找到。是因？为博士要送还战争领主抓来的人类壮丁，而把行踪暴露给了时间领主而被捕，并且除以流放地球和强制重生的处罚 第三任博士是在《蜘蛛之星》中为了消灭 eight legs，被蓝水晶溢出的致命辐射所伤回到 tardis 后在他曾经的导师帮助下重生。这集没有丢失，可以看到的 第四任博士是在《杉树》中重生的，为了阻止 master 威胁全宇宙的企图，博士爬上 pharos project 的无线电发射塔断开电缆，由于 master 倾斜了发射器，博士从数百英尺高空跌落地面奄奄一息尾随博士多时并暗中相助的的神秘影子观察者（也有人说这是 clara）附上其身帮助博士开始重生。 第五任博士是在老版《androzani 的洞穴》中博士和同伴 peri 在 androzani 次级行星的洞穴中无一间接触了蝙蝠产生的剧毒后感染血毒症，最后博士将仅得的唯一一份解药给了 peri，自己濒死而不得不重生。 第六任博士是在《time and the rani》中，女时间领主 rani 心思 lakertya 行星上用牵引光速击中了经过的 tardis 并迫使其着陆企图利用博士来帮助她控制宇宙历史的进程剧烈的相撞让博士失去意识重生。 第七任博士是在 1996 年神秘博士大电影中法师被 dalek 处死后要求博士把他的骨灰带回 gallifrey，途中法师扰乱了塔迪斯，使塔迪斯迫降在旧金山的一个帮派战争中。博士出塔迪斯的时候身中三枪，不过并不致命。送医后，因为不熟悉时间领主生理结构的主治医师不听博士劝告乱做手术而致博士死亡，因为麻醉剂的作用，重生被拖延了 n 小时，在停尸间完成重生。（ps：这任博士死的最冤了……活活被戳死……） 第八任博士是在 2013 年短片《博士之夜》中，为了救地球人（地球人？）cass 逃离时间之战未果而死，后被 karn 姐妹会救活 4 分钟后，选择直面时间之战从而喝下了重生药水，抛弃了博士之名以和平与理性之名重生成了 the warrior（另一种叫法是 the war doctor，或者是 8.5 任） the warrior 是在 50 周年特别篇《博士之日》中，听从了 clara 的劝告，放弃毁灭伽里弗雷，并与 10 任，11 任两位博士一同召唤 1 任~12 任博士，13 位博士一起把伽里弗雷冰冻保存后在塔迪斯里重生成第九任"}, {"title": "git 强制覆盖本地仓库", "path": "posts/2024/git_force_overwrite_local_repo.html", "tags": ["git"], "content": "git 强制覆盖本地仓库 git 强制覆盖本地仓库 git reset --hard origin/branch_name 是一个 Git 命令，用于将当前分支的状态重置为远程分支 branch_name 的状态。具体来说，它会： 将当前分支的 HEAD 指针重置为 origin/branch_name 的最新提交。 重置暂存区（index）以匹配这个提交。 重置工作目录中的文件以匹配这个提交。 这意味着本地所有未提交的更改和提交历史将被丢弃，工作目录将完全同步到远程分支的状态。请谨慎使用这个命令，因为它会丢失所有未提交的更改。"}, {"title": "现代加密学", "path": "posts/2024/modern_cryptography.html", "tags": ["加密"], "content": "现代加密学 AES 算法 核心特性 对称加密（同密钥加解密） 分组加密（128位块） 密钥长度：128/192/256位（对应10/12/14轮迭代） 加密流程 初始轮密钥加（异或操作） 多轮变换：字节替换（S-box）→ 行移位 → 列混淆 → 轮密钥加 最终轮省略列混淆 安全性 目前无有效破解手段 量子计算可能构成未来威胁 现代加密学基础 数学理论 ：数论/复杂性理论支撑（如RSA基于大数分解） 密钥体系 ：对称（AES）与非对称（RSA/ECC） 安全原则 ：Kerckhoffs原则（安全性依赖密钥而非算法保密） 协议层 ：SSL/TLS等实现端到端保护 质数的关键作用 非对称加密核心 ：RSA依赖大质数乘积分解难题，ECC使用质数域椭圆曲线 密钥生成基础 ：大质数对构造保障算法抗攻击性 下一代加密算法 后量子密码学 抗量子计算攻击 主要分支：\n     ▪ 格基（NTRU）\n     ▪ 码基（McEliece）\n     ▪ 哈希基（SPHINCS） NIST正在标准化进程中 同态加密 - 支持加密数据直接运算\n   - 当前瓶颈：计算效率/密文膨胀 经典密码学算法 类型 代表算法 特点 对称加密 AES, 3DES 高效，适合大数据量 非对称加密 RSA, ECC 密钥交换/数字签名 哈希算法 SHA-256, SHA-3 数据完整性验证 密钥交换协议 Diffie-Hellman 安全建立共享密钥 非对称加密密钥特性 私钥加密 → 公钥解密 ：可行但 不用于保密 （公钥公开） 核心用途 ：数字签名（哈希值加密验证身份/完整性）"}, {"title": "OpenSSL 加解密速查笔记", "path": "posts/2024/OpenSSL_encrypt_note.html", "tags": ["OpenSSL", "加密"], "content": "OpenSSL 加解密速查指南 核心加解密命令 文件加密 openssl enc -p -aes-256-cbc -pbkdf2 -iter 20000 -pass pass:密码明文 -in 输入文件 -out 输出文件.enc 文件解密 openssl enc -d -p -aes-256-cbc -pbkdf2 -iter 20000 -pass pass:密码明文 -in 加密文件.enc -out 解密文件 通用参数说明： -p ：显示使用的盐值和密钥 -aes-256-cbc ：AES 256位 CBC模式 -pbkdf2 ：使用PBKDF2密钥派生 -iter 20000 ：迭代次数（建议>=10000） 文件密钥操作 使用密钥文件加密 openssl enc -aes-256-cbc -pbkdf2 -in 明文文件 -out 加密文件 -pass file:密钥文件 使用密钥文件解密 openssl enc -d -aes-256-cbc -pbkdf2 -in 加密文件 -out 解密文件 -pass file:密钥文件 实用工具命令 生成随机文件 生成1MB随机数据： openssl rand -out random.bin 1048576 计算文件哈希值 SHA-256校验： openssl dgst -sha256 文件名 生成RSA密钥对 # 生成私钥\nopenssl genpkey -algorithm RSA -out private.pem\n\n# 提取公钥\nopenssl rsa -pubout -in private.pem -out public.pem 算法查询命令 命令 功能 openssl list -cipher-algorithms 查看对称加密算法 openssl list -public-key-algorithms 查看非对称加密算法 openssl list -digest-commands 查看支持的哈希算法"}, {"title": "Pull Request 的步骤", "path": "posts/2024/pull_request_steps.html", "tags": ["git", "pull request"], "content": "Pull Request 的步骤 为开源项目提 Pull Request (PR) 的步骤如下： 1. Fork 仓库： 前往你要贡献的开源项目仓库，点击右上角的 \"Fork\" 按钮，这将创建该仓库的副本到你的 GitHub 账户下。 2. 克隆仓库： 在你的本地机器上克隆你 Fork 的仓库。例如： git clone https://github.com/你的用户名/仓库名.git 然后进入克隆的仓库目录： cd 仓库名 3. 创建新分支： 创建一个分支以进行你的更改，并切换到该分支。例如： git checkout -b 新分支名 4. 进行更改： 在你的本地仓库中进行代码更改。确保遵循项目的代码规范和贡献指南。 5. 提交更改： 将你的更改添加并提交到新分支中。例如： git add .\ngit commit -m \"简要描述你的更改\" 6. 推送到 GitHub： 将你的更改推送到你的 Fork 仓库中。例如： git push origin 新分支名 7. 创建 Pull Request： 前往原始仓库的 GitHub 页面，你会看到一个提示，询问你是否要为你刚刚推送的分支创建 Pull Request。点击 \"Compare & pull request\" 按钮，填写 PR 的标题和描述，然后点击 \"Create pull request\"。 8. 与维护者沟通： PR 提交后，项目维护者可能会对你的更改进行审查，并要求你做出一些修订。保持沟通，及时响应审查意见。 9. 合并 PR： 如果你的更改通过了审查，维护者将会合并你的 PR。你的贡献将被包含在项目中。 通过以上步骤，你就可以为开源项目贡献代码了。"}, {"title": "obsidian快捷键", "path": "posts/2024/obsidian_shortcut_key.html", "tags": ["obsidian"], "content": "obsidian快捷键 快捷键 效果 Ctrl+K 快速切换 Ctrl+A 选中全部 Ctrl+S 保存 Ctrl+M 重命名文件 Ctrl+, 打开设置 Ctrl+K 关闭所有标签页 Ctrl+W 关闭当前标签页 Ctrl+ ` 切换实时预览/源码视图 Ctrl+N 新建笔记 Ctrl+F 在当前文件中查找 Ctrl+H 在当前文件中查找并替换 Ctrl+O 在系统资源管理器中显示 Ctrl+; 增加文档属性 Ctrl+Right Arrow 折叠展开右侧边栏 Ctrl+Left Arrow 折叠展开左侧边栏 Ctrl+Z 文本后退 Ctrl+D Quick add 的快速捕获日记功能 Ctrl+1 插入当前年月日 Ctrl+2 插入当前时间 Ctrl+P 打开命令面板 Ctrl+Shift+V 切换编辑/预览视图 Ctrl+Shift+F 在所有文件中查找 Ctrl+Shift+E 显示文件列表 Ctrl+Alt+B 打开大纲 Alt+Left Arrow 后退 Alt+Right Arrow 前进 [\n    {\"Ctrl+K\": \"快速切换\"},\n\n    {\"Ctrl+A\": \"选中全部\"},\n\n    {\"Ctrl+S\": \"保存\"},\n\n    {\"Ctrl+M\": \"重命名文件\"},\n\n    {\"Ctrl+,\": \"打开设置\"},\n\n    {\"Ctrl+K\": \"关闭所有标签页\"},\n\n    {\"Ctrl+W\": \"关闭当前标签页\"},\n\n    {\"Ctrl+`\": \"切换实时预览/源码视图\"},\n\n    {\"Ctrl+N\": \"新建笔记\"},\n\n    {\"Ctrl+F\": \"在当前文件中查找\"},\n\n    {\"Ctrl+H\": \"在当前文件中查找并替换\"},\n\n    {\"Ctrl+O\": \"在系统资源管理器中显示\"},\n\n    {\"Ctrl+;\": \"增加文档属性\"},\n\n    {\"Ctrl+1\": \"插入当前年月日\"}\n\n    {\"Ctrl+2\": \"插入当前时间\"}\n\n    {\"Ctrl+Right Arrow\": \"折叠展开右侧边栏\"},\n\n    {\"Ctrl+Left Arrow\": \"折叠展开左侧边栏\"},\n\n    {\"Ctrl+Z\": \"文本后退\"},\n\n    {\"Ctrl+D\": \"Quick add 的快速捕获日记功能\"}\n\n    {\"Ctrl+P\": \"打开命令面板\"},\n\n    {\"Ctrl+Shift+V\": \"切换编辑/预览视图\"},\n\n    {\"Ctrl+Shift+F\": \"在所有文件中查找\"},\n\n    {\"Ctrl+Shift+E\": \"显示文件列表\"},\n\n    {\"Ctrl+Alt+B\": \"打开大纲\"},\n\n    {\"Alt+Left Arrow\": \"后退\"},\n\n    {\"Alt+Right Arrow\": \"前进\"}\n]"}, {"title": "从 git 提交中移除文件", "path": "posts/2024/remove_file_from_git_history.html", "tags": ["git"], "content": "从 git 提交中移除文件 移除单个文件的提交历史 删除一个文件的提交历史，git 官方推荐一个 python 工具 git filter-repo ，下面是命令 uv venv .venv\\Scripts\\activate uv pip install git-filter-repo git filter-repo --path templates.json --invert-paths --force 这个命令会从所有分支的所有提交历史中删除 templates.json 文件 移除一个文件夹的提交历史 git filter-repo --path myfolder/ --invert-paths --force 这个命令会删除 myfolder/ 文件夹及其该文件夹下所有内容的提交历史"}, {"title": "git 命令手册", "path": "posts/2024/git_Cli.html", "tags": ["git"], "content": "git 命令手册 常用语句 == 初始化本地git仓库（创建新仓库）\ngit init\n\n== 配置用户名\ngit config --global user.name \"xxx\"\n\n== 配置邮件\ngit config --global user.email \"xxx@xxx.com\"\n\n== git status等命令自动着色\ngit config --global color.ui true\ngit config --global color.status auto\ngit config --global color.diff auto\ngit config --global color.branch auto\ngit config --global color.interactive auto\n\n== remove proxy configuration on git\ngit config --global --unset http.proxy\n\n== clone远程仓库\ngit clone git+ssh://git@192.168.53.168/VT.git\n\n== 查看当前版本状态（是否修改）\ngit status\n\n== 添加xyz文件至index\ngit add xyz\n\n== 增加当前子目录下所有更改过的文件至index\ngit add .\n\n== 提交\ngit commit -m 'xxx'\n\n== 合并上一次提交（用于反复修改）\ngit commit --amend -m 'xxx'\n\n== 将add和commit合为一步\ngit commit -am 'xxx'\n\n== 删除index中的文件\ngit rm xxx\n\n== 递归删除\ngit rm -r *\n\n== 显示提交日志\ngit log\n\n== 显示1行日志 -n为n行\ngit log -1\ngit log -5\n\n== 显示提交日志及相关变动文件\ngit log --stat\ngit log -p -m\n\n== 显示某个提交的详细内容\ngit show dfb02e6e4f2f7b573337763e5c0013802e392818\n\n== 可只用commitid的前几位\ngit show dfb02\n\n== 显示HEAD提交日志\ngit show HEAD\n\n== 显示HEAD的父（上一个版本）的提交日志 ^^为上两个版本 ^5为上5个版本\ngit show HEAD^\n\n== 显示已存在的tag\ngit tag\n\n== 增加v2.0的tag\ngit tag -a v2.0 -m 'xxx'\n\n== 显示v2.0的日志及详细内容\ngit show v2.0\n\n== 显示v2.0的日志\ngit log v2.0\n\n== 显示所有未添加至index的变更\ngit diff\n\n== 显示所有已添加index但还未commit的变更\ngit diff --cached\n\n== 比较与上一个版本的差异\ngit diff HEAD^\n\n== 比较与HEAD版本lib目录的差异\ngit diff HEAD -- ./lib\n\n== 比较远程分支master上有本地分支master上没有的\ngit diff origin/master..master\n\n== 只显示差异的文件，不显示具体内容\ngit diff origin/master..master --stat\n\n== 增加远程定义（用于push/pull/fetch）\ngit remote add origin git+ssh://git@192.168.53.168/VT.git\n\n== 显示本地分支\ngit branch\n\n== 显示包含提交50089的分支\ngit branch --contains 50089\n\n== 显示所有分支\ngit branch -a\n\n== 显示所有原创分支\ngit branch -r\n\n== 显示所有已合并到当前分支的分支\ngit branch --merged\n\n== 显示所有未合并到当前分支的分支\ngit branch --no-merged\n\n== 本地分支改名\ngit branch -m master master_copy\n\n== 从当前分支创建新分支master_copy并检出\ngit checkout -b master_copy\ngit checkout -b master master_copy\n\n== 检出已存在的features/performance分支\ngit checkout features/performance\n\n== 检出远程分支hotfixes/BJVEP933并创建本地跟踪分支\ngit checkout --track hot"}, {"title": "浏览器UA值", "path": "posts/2024/browser_UA_value.html", "tags": ["浏览器"], "content": "浏览器UA值 简单搜索的UA值 Mozilla/5.0 (Linux; Android 11; RMX3161 Build/RKQ1.201217.002; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/76.0.3809.89 Mobile Safari/537.36 T7/12.16 SearchCraft/3.9.1 (Baidu; P1 11)​ bing的UA值 Mozilla/5.0 (Linux; Android 8.0.0; MHA-AL00 Build/HUAWEIMHA-AL00; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/68.0.3440.91 Mobile Safari/537.36 BingWeb/6.9.6"}, {"title": "git-crypt 官方文档", "path": "posts/2024/git-crypt_official_doc.html", "tags": ["git-crypt", "git"], "content": "git-crypt 官方文档 原文档: https://github.com/AGWA/git-crypt/blob/master/README.md git -crypt - transparent file encryption in git git-crypt enables transparent encryption and decryption of files in a\ngit repository.  Files which you choose to protect are encrypted when\ncommitted, and decrypted when checked out.  git-crypt lets you freely\nshare a repository containing a mix of public and private content.\ngit-crypt gracefully degrades, so developers without the secret key can\nstill clone and commit to a repository with encrypted files.  This lets\nyou store your secret material (such as keys or passwords) in the same\nrepository as your code, without requiring you to lock down your entire\nrepository. git-crypt was written by Andrew Ayer ( agwa@andrewayer.name ).\nFor more information, see https://www.agwa.name/projects/git-crypt . Building git-crypt See the INSTALL.md file. Using git-crypt Configure a repository to use git-crypt: cd repo\ngit-crypt init Specify files to encrypt by creating a .gitattributes file: secretfile filter=git-crypt diff=git-crypt\n*.key filter=git-crypt diff=git-crypt\nsecretdir/** filter=git-crypt diff=git-crypt Like a .gitignore file, it can match wildcards and should be checked into\nthe repository.  See below for more information about .gitattributes.\nMake sure you don't accidentally encrypt the .gitattributes file itself\n(or other git files like .gitignore or .gitmodules).  Make sure your\n.gitattributes rules are in place before you add sensitive files, or\nthose files won't be encrypted! Share the repository with others (or with yourself) using GPG: git-crypt add-gpg-user USER_ID USER_ID can be a key ID, a full fingerprint, an email address, or\nanything else that uniquely identifies a public key to GPG (see \"HOW TO\nSPECIFY A USER ID\" in the gpg man page).  Note: git-crypt add-gpg-user will add and commit a GPG-encrypted key file in the .git-crypt directory\nof the root of your repository. Alternatively, you can export a symmetric secret key, which you "}, {"title": "第三方邮箱客户端配置QQmail & Foxmail", "path": "posts/2024/qqmail_third_party_config.html", "tags": ["邮箱"], "content": "第三方邮箱客户端配置QQmail & Foxmail 如果您的邮件客户端不在上述列出的范围内，您可以尝试如下通用配置： 接收邮件服务器：imap.qq.com 发送邮件服务器：smtp.qq.com 账户名：您的 QQ 邮箱账户名（如果您是 VIP 邮箱，账户名需要填写完整的邮件地址） 密码：您的 QQ 邮箱密码 电子邮件地址：您的 QQ 邮箱的完整邮件地址 如何设置 IMAP 服务的 SSL 加密方式？ 使用 SSL 的通用配置如下： 接收邮件服务器：imap.qq.com，使用 SSL，端口号 993 发送邮件服务器：smtp.qq.com，使用 SSL，端口号 465 或 587 账户名：您的 QQ 邮箱账户名（如果您是 VIP 帐号或 Foxmail 帐号，账户名需要填写完整的邮件地址） 密码：您的 QQ 邮箱密码 电子邮件地址：您的 QQ 邮箱的完整邮件地址"}, {"title": "手机QQ文件存储路径", "path": "posts/2024/android_QQ_file_storage_path.html", "tags": ["手机QQ", "Android"], "content": "手机QQ文件存储路径 我的手机/android/data/com.tencent.mobileqq/tencent/qqfile_recv"}, {"title": "生成 GPG 密钥", "path": "posts/2024/gen_GPG_key.html", "tags": ["GPG"], "content": "生成 GPG 密钥 下载 GPG： gpg4win 生成 gpg 密钥 gpg2 --full-gen-key      < 2.1.17\ngpg --full-generate-key  >= 2.1.17 gpg (GnuPG) 2.4.3; Copyright (C) 2023 g10 Code GmbH\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.\n\nPlease select what kind of key you want:\n   (1) RSA and RSA\n   (2) DSA and Elgamal\n   (3) DSA (sign only)\n   (4) RSA (sign only)\n   (9) ECC (sign and encrypt) *default*\n  (10) ECC (sign only)\n  (14) Existing key from card\nYour selection? 1           <--选择密钥类型\nRSA keys may be between 1024 and 4096 bits long.\nWhat keysize do you want? (3072)         <--选择密钥长度，在 1024到4096 之间，默认为 3072\nRequested keysize is 3072 bits\nPlease specify how long the key should be valid.\n         0 = key does not expire\n      <n>  = key expires in n days    <-- <n>  = 密钥在 n 天后过期\n      <n>w = key expires in n weeks   <-- <n>w = 密钥在 n 周后过期\n      <n>m = key expires in n months  <-- <n>m = 密钥在 n 月后过期\n      <n>y = key expires in n years   <-- <n>y = 密钥在 n 年后过期\nKey is valid for? (0)     <--选择密钥有效期\nKey does not expire at all\nIs this correct? (y/N)   <--确认\n\nGnuPG needs to construct a user ID to identify your key.\n\nReal name: YOUR_NAME      <--输入密钥名称\nEmail address: test@test.com       <--输入密钥邮箱\nComment: test          <--输入密钥注释\nYou are using the 'utf-8' character set.\nYou selected this USER-ID:\n    \"YOUR_NAME (test) <test@test.com>\"\n\nChange (N)ame, (C)omment, (E)mail or (O)kay/(Q)uit? o  <--最终确认，如果你想修改密钥名称则输入 n，以此类推，最终确认则输入 o\nWe need to generate a lot of random bytes. It is a good idea to perform\nsome other action (type on the keyboard, move the mouse, utilize the\ndisks) during the prime generation; this gives the random number\ngenerator a better chance to gain enough entropy.    <--这一步输入密钥密码\ngpg: revocation certificate stored as 'C:\\\\Users\\\\user\\\\AppData\\\\Roaming\\\\gnupg\\\\openpgp-revocs.d\\\\095A4F5A6125D5EB02FE5CB824B8F8F7EAFFD84D.rev'\npublic and secret key created and signed.\n\npub   rsa3072 2024-02-25 [SC]\n      095A4F5A6125D5EB02"}, {"title": "使用 Python 生成静态网页", "path": "posts/2025/use_python_gen_site.html", "tags": ["python", "site"], "content": "使用 Python 生成静态网页 环境： PS D:\\workspace\\blog> python --version\n\nPython 3.12.0 步骤： 第一步，创建虚拟环境 uv venv .venv\\Scripts\\activate 第二步，下载依赖 uv pip install -r requirements.txt 第三步，生成索引（本地跳过这一步） uv run .github\\scripts\\update_indexes.py 第四步，生成静态网页 uv run .github\\scripts\\static_gen.py 第五步，预览 python -m http.server -d site 在浏览器中访问 http://localhost:8000 创建新的文章 在 posts 文件夹下按照年份创建文件，格式为 ---\ntitle: 标题\ndate: 2025-04-13\ntags: [tag1, tag2]\ncategory: [category]\n---\n\n# 标题 写完之后生成索引 uv run .github\\scripts\\update_indexes.py 生成静态网页 uv run .github\\scripts\\static_gen.py 本地预览 python -m http.server -d site 在浏览器中访问 http://localhost:8000 部署 该项目配置了 GitHub Actions 工作流，在你将代码推送到 GitHub 时自动构建和部署。 确保已在 GitHub 仓库设置中启用了 GitHub Pages 推送更改到 GitHub GitHub Actions 将自动构建并部署网站 自定义 修改 template.html 更改网站布局 修改 assets/styles.css 更改网站样式 在 static_gen.py 文件的顶部修改网站标题和其他配置"}, {"title": "安装 WSL2 并迁移到 D 盘", "path": "posts/2025/install_wsl2_and_to_d_disk.html", "tags": ["WSL2", "Linux"], "content": "安装 WSL2 并迁移到 D 盘 安装 WSL2 以下是在 Windows 上安装 WSL2 的主要步骤： 启用必要功能 在 PowerShell（管理员权限）中执行下列命令启用所需功能并重启计算机： 启用WSL功能： dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart 启用虚拟机平台: dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart 重启电脑： Restart-Computer 安装 Ubuntu 在 PowerShell 中使用命令安装： wsl --install -d Ubuntu 安装完成后，启动并按照指示设置用户名和密码。 迁移到 D 盘 以下是把 WSL2 迁移到 D 盘的步骤： 在 PowerShell 或终端中使用 wsl --list --verbose 查看当前已安装的 WSL 发行版的名称，发行版名为 Ubuntu。 导出该发行版到一个 .tar 文件（路径可自行更改），例如将其暂时保存到 D 盘的临时目录: wsl --export Ubuntu D:\\temp\\ubuntu_export.tar 从系统中卸载（注册表中移除）该发行版： wsl --unregister Ubuntu 在 D 盘创建一个目录用于存放新的发行版文件，例如 D:\\WSL2\\Ubuntu，然后将刚才导出的 tar 文件导入到该目录： wsl --import Ubuntu D:\\WSL2\\Ubuntu D:\\temp\\ubuntu_export.tar --version 2 导入完成后，新的发行版即部署在 D 盘，登录方法保持不变，可通过下列命令进入该发行版： wsl -d Ubuntu 如需设置新的发行版为默认 WSL 发行版，可使用： wsl --set-default Ubuntu 这样就完成了在 D 盘安装或迁移相应 WSL2 发行版的流程。若需要多个发行版，也可按照上述方法依次导出-导入。 查看安装的 Ubuntu 版本 打开 WSL2 终端。 cat /etc/os-release 输出结果中， VERSION 和 VERSION_ID 行会显示 Ubuntu 的版本信息。"}, {"title": "跨系统避免换行符导致字节差异的方法", "path": "posts/2025/cross-platform-byte-control.md.html", "tags": ["跨平台", "文件操作", "换行符", "UTF-8", "字节控制"], "content": "跨系统避免换行符导致字节差异的方法 在不同操作系统下，会因为换行符导致字节差异，下面介绍了一个方法精确控制输出内容的字节。 Linux 下 LC_ALL=C.UTF-8 echo -n \"context\" > file.txt echo -n \"context\" | iconv -t UTF-8 > file.txt Windows 下 [System.IO.File]::WriteAllBytes(\"file.txt\", [System.Text.Encoding]::UTF8.GetBytes(\"content\")) 注意事项 这两个命令都可以 精确控制输出内容的字节 ，避免 Windows（ \\r\\n ）和 Linux（ \\n ）因不同换行策略导致的字节不同。 在需要严格一致的文件内容（如校验哈希、跨平台脚本等场景）时，推荐使用上述方式。"}, {"title": "zed 使用笔记", "path": "posts/2025/zed_use.html", "tags": ["zed"], "content": "zed 使用笔记 系统：Windows11 24H2 下载： https://github.com/deevus/zed-windows-builds settings.json https://zed.dev/docs/configuring-zed C:\\Users\\admin\\AppData\\Roaming\\Zed snippets.json https://zed.dev/docs/snippets C:\\Users\\admin\\AppData\\Roaming\\Zed 示例： {\n    \"zed snippets\": {\n        \"body\": \"Zed is a good editor.\",\n        \"description\": \"zed snippets example\",\n        \"prefix\": \"zed\"\n    }\n} 如果你想创建针对 JavaScript 文件的代码片段，你的文件将是 javascript.json 格式化 ctrl+shift+i 保存加格式化 我的 Zed 配置(2025-03-21 更新) {\n    // \"base_keymap\": \"VSCode\", //键盘快捷键\n\n    // \"vim_mode\": true, //vim 模式\n    // \"relative_line_numbers\": true, //相对行号\n\n    \"show_edit_predictions\": false,\n    \"theme\": \"One Dark\", //主题\n\n    \"buffer_line_height\": \"comfortable\", //行高\n\n    \"buffer_font_family\": \"JetBrains Mono\", //编辑区字体\n    \"buffer_font_size\": 17, //编辑区字体大小\n    \"buffer_font_fallbacks\": [\"JetBrains Mono\"], //编辑区后备字体\n    \"ui_font_family\": \"Zed Plex Mono\", //UI 字体\n    \"ui_font_size\": 17, //UI 大小\n    \"show_whitespaces\": \"all\", //显示空格\n    \"buffer_font_features\": {\n        \"calt\": false //连字，false 表示关闭\n    },\n\n    // AI 助手\n    \"assistant\": {\n        \"default_model\": {\n            \"provider\": \"openai\",\n            \"model\": \"deepseek-v3\"\n        },\n        \"inline_alternatives\": [\n            {\n                \"provider\": \"openai\",\n                \"model\": \"deepseek-v3\"\n            }\n        ],\n        \"button\": true,\n        \"version\": \"2\"\n    },\n\n    //语言模型\n    \"language_models\": {\n        \"openai\": {\n            \"api_url\": \"https://dashscope.aliyuncs.com/compatible-mode/v1\",\n            \"available_models\": [\n                {\n                    \"name\": \"qwq-plus\",\n                    \"display_name\": \"QwQ-Plus\",\n                    \"max_tokens\": 131072,\n                    \"max_output_tokens\": 8192\n                },\n                {\n                    \"name\": \"qwq-32b\",\n                    \"display_name\": \"QwQ-32B\",\n                    \"max_tokens\": 131072,\n                    \"max_output_tokens\": 8192\n                },"}, {"title": "自用 git hook", "path": "posts/2025/git-hook.html", "tags": ["git"], "content": "自用 git hook post-commit 路径：.git/hooks/post-commit #!/bin/sh\n\n# 定义计数器文件的路径\nCOUNTER_FILE=\".git_commit_counter\"\n\n# 检查计数器文件是否存在，如果不存在，则初始化为0\nif [ ! -f \"$COUNTER_FILE\" ]; then\n    echo 0 > \"$COUNTER_FILE\"\nfi\n\n# 读取当前计数\ncount=$(cat \"$COUNTER_FILE\")\ncount=$((count+1))\n\n# 更新计数器文件\necho $count > \"$COUNTER_FILE\"\n\n# 每10次提交执行一次git push\nif [ \"$count\" -eq 10 ]; then\n    git push origin main\n    # 重置计数器\n    echo 0 > \"$COUNTER_FILE\"\nfi 这个钩子用于自动计数提交次数，主要功能： 创建/检查 .git_commit_counter 文件（需加入 .gitignore ） 读取并更新提交计数（每次提交 +1） 每 10 次提交自动推送至远程 该脚本可减少手动推送次数，提高频繁提交时的工作效率。 post-commit 路径：.git/hooks/post-commit #!/bin/sh\n\ngit push origin main 这个钩子的作用是在每次成功提交（commit）后自动执行 git push 命令 commit-msg 路径：.git/hooks/commit-msg #!/bin/sh\n\n# 获取当前时间，格式为年-月-日 时:分:秒\nCOMMIT_TIME=$(date \"+%Y-%m-%d %H:%M:%S\")\n\n# 在提交信息末尾添加当前时间\necho \"$COMMIT_TIME\" >> $1 这个钩子会在提交信息之后添加当前时间"}, {"title": "GitHub 打野指南", "path": "posts/2025/How-to-Search-for-AI-API-Keys-on-GitHub.html", "tags": ["GitHub", "AI"], "content": "GitHub 打野指南 有很多开发者很粗心，会把 .env 给推送到 GitHub 的公开仓库，这里面可能会有 API Key，其中就有 AI 模型的 key GitHub 的搜索功能很强大，可以用正则表达式搜索，我这里准备了几个正则表达式 阿里云百炼平台 DASHSCOPE_API_KEY=sk- path:**/.env DeepSeek DEEPSEEK_API_KEY=sk- path:**/.env OpenRouter OPENROUTER_API_KEY=sk- path:**/.env Tavily TAVILY_API_KEY=tvly- path:**/.env EXA EXA_API_KEY= path:**/.env Google Gemini GOOGLE_GEMINI_KEY=AI path:**/.env pplx PERPLEXITY_API_KEY=pplx- path:**/.env"}, {"title": "yt-dlp 使用", "path": "posts/2025/yt-dlp.html", "tags": ["yt-dlp", "视频下载", "python"], "content": "yt-dlp 使用 yt-dlp 是一个强大的视频下载工具，支持从多个网站下载视频和音频。它是 youtube-dl 的一个分支，提供了更多的功能和更好的性能。 这个工具比 you-get 好用，因为它是一个命令行工具，而不是一个 Python 库，使用起来更简单。 下载 https://github.com/yt-dlp/yt-dlp/releases ，下载最新版本的 yt-dlp 可执行文件，并将其放在系统的 PATH 中 基本用法 使用 Cookie-Editor ，导出网站的 cookies，保存为 cookies.txt 文件。 示例命令： yt-dlp --cookies \"cookies.txt\" https://x.com/i/status/xxxxxxxxxxxxxxxx 这将下载指定 URL 的视频或音频。"}, {"title": "win11 右键菜单切换到 win10 右键菜单", "path": "posts/2025/win11-context-menu-to-win10-context-menu.html", "tags": ["Windows", "Terminal"], "content": "win11 右键菜单切换到 win10 右键菜单 官方解答 https://learn.microsoft.com/zh-cn/answers/questions/4106782/windows11 在 win11 的终端运行： reg add \"HKCU\\Software\\Classes\\CLSID{86ca1aa0-34aa-4e8b-a509-50c905bae2a2}\\InprocServer32\" /f /ve 然后重启就可以切换到 win10 的右键菜单了。 恢复命令 reg delete \"HKCU\\Software\\Classes\\CLSID{86ca1aa0-34aa-4e8b-a509-50c905bae2a2}\\InprocServer32\" /va /f"}, {"title": "SOPS:Secrets OPerationS", "path": "posts/2025/SOPS.html", "tags": ["sops", "加密", "age", "gpg"], "content": "SOPS:Secrets OPerationS 安装 https://github.com/getsops/sops 使用 创建 .sops.yaml 文件 creation_rules:\n  - age: 'age1xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx' #age 公钥\n#   - pgp: 'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx' #PGP 公钥 age 使用笔记： age-note gpg 使用笔记： gpg-note Windows age 的私钥存放在 C:\\Users\\24109\\AppData\\Roaming\\sops\\age\\keys.txt Linux （待补充） sops 加密二进制文件 sops --encrypt --input-type binary --output secret.json secret.bin sops --decrypt --output-type binary --output secret.bin secret.json sops 加密文本文件 原地加密 sops -e -i secrets.txt 加密到新文件 sops --encrypt --output secrets.enc.txt secrets.txt 查看或编辑加密文件 sops secrets.enc.txt 解密文件（终端输出） sops --decrypt a.txt 解密到新文件 sops --decrypt --output secrets.decrypted.txt secrets.enc.txt"}, {"title": "如何在 zed 中配置 REPL（python）", "path": "posts/2025/zed-REPL-guide.html", "tags": ["python", "zed", "REPL"], "content": "如何在 zed 中配置 REPL（python） 在 zed 的 settings.json 中写入 \"lsp\": {\n        \"python\": {\n            \"initialization_options\": {\n                \"path\": \"D:\\\\Python\\\\Python313\\\\Lib\\\\site-packages\" //这里是 pip install 的位置\n            }\n        }\n    },\n    \"jupyter\": {\n        \"kernel_selections\": {\n            \"python\": \"ipykernel\"\n        }\n    } 然后安装运行以下命令 pip install ipykernel python -m ipykernel install --user"}, {"title": "ollama 运行 DeepSeek 模型", "path": "posts/2025/ollama_run_deepseek.html", "tags": ["ollama", "AI", "DeepSeek"], "content": "ollama 运行 DeepSeek 模型 最近 DeepSeek-R1 开源，风头无两，用 o1 几十分之一的成本训练出一个比肩 o1 的模型，而且还开源，不仅把模型开源，还把训练方法开源，而且还是 MIT 协议，随意商用 除此之外，DeepSeek 还用 R1 的蒸馏数据训练了其它几个火爆的开源模型：Qwen、Llama，推出了 DeepSeek-R1-Distill-Llama 和 DeepSeek-R1-Distill-Qwen ，其中 DeepSeek-R1-Distill-Qwen 有 1.5B 版本 然后看网上有人说 1.5B 的小模型可以在任何设备上运行，我就心痒痒了，想在我的小破电脑上玩一下这个模型 我的电脑配置 12th Gen Intel(R) Core(TM) i5-12500H 16 GB内存 步骤 1. 下载 ollama https://ollama.com/download Windows 下载好后要把 ollama 加入到环境变量中 2. 下载模型 在魔搭社区找到 这个网页 ，找到 DeepSeek-R1-Distill-Qwen-1.5B ，下载模型： git clone https://www.modelscope.cn/unsloth/DeepSeek-R1-Distill-Qwen-1.5B-GGUF.git 3. 创建 Modelfile 文件 进入 DeepSeek-R1-Distill-Qwen-1.5B-GGUF 文件夹 cd DeepSeek-R1-Distill-Qwen-1.5B-GGUF 创建 Modelfile 文件，在 Modelfile 中写入 GGUF 的路径： FROM D:\\workspace\\R1-Qwen\\DeepSeek-R1-Distill-Qwen-1.5B-GGUF\\DeepSeek-R1-Distill-Qwen-1.5B-Q2_K.gguf 4. 把本地模型加入到 ollama 中 ollama create DeepSeek-R1-Distill-Qwen-1.5B 成功会报： gathering model components\ncopying file sha256:e18142b69b2dbdac59eca6bf77dde2054078003bcb9534e02e7ca1cf26eb5675 100%\nparsing GGUF\nusing existing layer sha256:e18142b69b2dbdac59eca6bf77dde2054078003bcb9534e02e7ca1cf26eb5675\nwriting manifest\nsuccess 查看模型： ollama list 报： NAME                                    ID              SIZE      MODIFIED\nDeepSeek-R1-Distill-Qwen-1.5B:latest    3c5f0a638147    752 MB    2 minutes ago 5. 运行 ollama run DeepSeek-R1-Distill-Qwen-1.5B:latest 就可以在终端里对话了 命令汇总 git clone https://www.modelscope.cn/unsloth/DeepSeek-R1-Distill-Qwen-1.5B-GGUF.git cd DeepSeek-R1-Distill-Qwen-1.5B-GGUF 创建 Modelfile，并把 GGUP 的路径写入 ollama create DeepSeek-R1-Distill-Qwen-1.5B ollama create DeepSeek-R1-Distill-Qwen-1.5B ollama run DeepSeek-R1-Distill-Qwen-1.5B:latest 感受 ollama 很简单，很易用 1.5B 的小模型会胡言乱语 模型运行时会吃满 CPU 和内存，不能再打开第二个软件了，打开会卡死"}, {"title": "在 Windows 上配置 Rust 环境", "path": "posts/2025/Rust_Windows_Config.html", "tags": ["Rust"], "content": "在 Windows 上配置 Rust 环境 起因：想编译 Zed 的 Windows 版，但不想下载 visual studio 视频： https://www.bilibili.com/video/BV12RDhYPE7M 步骤简化 一、配置 GCC 环境 在 mingw 网页下下载 x86_64-15.1.0-release-win32-seh-ucrt-rt_v12-rev0.7z 二、下载 Rust 三、配置用户变量 变量                                值\nRUSTUP_DIST_SERVER                 https://mirrors.ustc.edu.cn/rust-static\nRUSTUP_UPDATE_ROOT                 https://mirrors.ustc.edu.cn/rust-static/rustup\nRUSTUP_HOME                        D:\\Rust\\rustup\nCARGO_HOME                         D:\\Rust\\cargo 四、安装 点击下载的 rustup-init.exe ，运行开启一个终端，按照步骤安装 五、配置 cargo 镜像源 在 D:\\Rust\\cargo\\config.toml 中添加如下内容 [source.crates-io]\nreplace-with = 'ustc'\n\n[source.ustc]\nregistry = \"sparse+https://mirrors.ustc.edu.cn/crates.io-index/\"\n\n[registries.ustc]\nindex = \"sparse+https://mirrors.ustc.edu.cn/crates.io-index/\" 详细解释 配置 gcc 环境 在 mingw 网页下下载 x86_64-15.1.0-release-win32-seh-ucrt-rt_v12-rev0.7z ，其中 x86_64 是 64 位的， seh 是异常处理方式， ucrt 是 C 运行时库， rt_v12-rev0 是版本号，15.1.0 是 GCC 的版本号。 解压后把 bin 路径放到环境变量中 检测 gcc -v\n\nUsing built-in specs.\nCOLLECT_GCC=D:\\workspace\\mingw64\\bin\\gcc.exe\nCOLLECT_LTO_WRAPPER=D:/workspace/mingw64/bin/../libexec/gcc/x86_64-w64-mingw32/15.1.0/lto-wrapper.exe\nTarget: x86_64-w64-mingw32\nConfigured with: ../../../src/gcc-15.1.0/configure --host=x86_64-w64-mingw32 --build=x86_64-w64-mingw32 --target=x86_64-w64-mingw32 --prefix=/mingw64 --with-sysroot=/c/buildroot/x86_64-1510-win32-seh-ucrt-rt_v12-rev0/mingw64 --enable-host-shared --disable-multilib --enable-languages=c,c++,fortran,lto --enable-libstdcxx-time=yes --enable-threads=win32 --enable-libstdcxx-threads=yes --enable-libgomp --enable-libatomic --enable-lto --enable-graphite --enable-checking=release --enable-mingw-wildcard --enable-fully-dynamic-string --enable-version-specific-runtime-libs --enable-libstdcxx-filesystem-ts=yes --disable-libssp --disable-libstdcxx-pch --disable-libstdcxx-debug --enable-bootstrap --disable-rpath --disable-win32-registry --disable-nls --disable-werror --disable-symvers --with-gnu-as --with-g"}, {"title": "个人字体", "path": "posts/2025/font.html", "tags": ["font"], "content": "个人常用字体 Typst 使用字体： Source Han Sans CN VS Code 和 Zed 使用字体： JetBrains Mono"}, {"title": "修改 npm node_modules 位置", "path": "posts/2025/npm-config.html", "tags": ["node", "npm", "node_modules"], "content": "修改 npm node_modules 位置 修改 npm install 时的 node_modules 位置 npm config set prefix \"D:\\npm\" 修改 npm cache 的位置 查看 npm cache 位置 npm config get cache 修改 npm config set cache \"D:\\npm\\cache\""}, {"title": "回滚提交", "path": "posts/2025/Rollback-commit.html", "tags": ["git"], "content": "回滚提交 要强制回滚到前两个提交之前，可以使用以下 Git 命令： 打开终端并导航到项目目录： 查看提交历史以确认目标提交： git log --oneline 强制回滚到前两个提交之前（假设目标提交的哈希为 abc123 ）： git reset --hard abc123 如果需要将更改强制推送到远程仓库： git push origin --force 注意 ：强制回滚和推送会覆盖远程仓库的历史记录"}, {"title": "Passkey:Secure,Convenient Login", "path": "posts/2025/introduce-passkey.html", "tags": ["passkey", "密码学"], "content": "Passkey:Secure,Convenient Login 第一部分：Passkey 的基本原理 (密钥对) 您的理解： passkey 是一对密钥对，私钥存储在设备的安全芯片内，无法导出，公钥发送到相对于的网站服务器，只有私钥公钥对上才能登陆，以此免去了输密码的烦恼，也就减少了被盗风险。 这个理解完全正确！ 这就是 Passkey 的基石。 非对称加密 ：您准确地指出了这是基于“密钥对”（公钥和私钥）的技术。 安全存储 ：私钥确实存储在设备的安全硬件中，如苹果的 Secure Enclave、Google 的 Titan M 芯片，或 Windows 电脑的 TPM 模块。这是它安全的关键，因为私钥物理上无法被恶意软件或远程攻击者读取和盗走。 不可导出 ：这是硬件层面的设计，保证了私钥“生于斯，长于斯，终于斯”，绝不会离开设备。 登录流程 ：您描述的“对上才能登陆”在技术上是一个“挑战-响应”签名过程。 服务器发送一个随机的“挑战”数据给你。 你的设备使用安全芯片内的私钥对这个“挑战”进行“签名”。 设备将签名后的结果发回给服务器。 服务器用它之前存储的你的公钥来验证这个签名。验证通过，就证明你确实是私钥的持有者，登录成功。 核心优势 ：您也说对了，它解决了两大痛点： 便捷性 ：无需记忆和输入密码，用面容 ID、指纹或 PIN 码即可完成。 安全性 ： 防钓鱼 ：由于 Passkey 与网站域名绑定，你无法在假的钓鱼网站上使用真网站的 Passkey，从根本上杜绝了钓鱼攻击。 防数据泄露 ：即使网站服务器被黑，泄露的也只是公钥，攻击者无法用公钥反推出你的私钥，你的账户依然安全。 第二部分：Google 和 Apple 的角色与云同步 您的理解： Google 和 apple 的密码管理器是存储加密后的私钥，是使用设备本身的加密来加密，例如在 Windows 上是 Windows hello，这样，无论是云厂商还是攻击者都无法窃取密码。 这个理解方向正确，但在具体实现上有一个非常关键的微妙差别。 您的结论“无论是云厂商还是攻击者都无法窃取”是 正确 的，但实现方式比您想象的更精妙。 这里需要区分两种 Passkey： 设备绑定 Passkey (Device-bound Passkey) ：这是最传统的模式。私钥严格绑定在单一设备的硬件中，无法移动。如果你换了新手机，就得在新手机上重新注册一个 Passkey。安全但不够方便。 可同步 Passkey (Syncable Passkey) ：这是 Apple 和 Google 等厂商大力推广的模式，也是我们通常所说的“Passkey”。它的目标是解决“换设备就不方便”的问题。 现在来修正一下您的理解： 云端同步的不是私钥本身，而是一个经过端到端加密的、可同步的“凭证数据包”。 当您创建一个 可同步的 Passkey 时，这个 Passkey 的凭证（包含了密钥材料）会被一个只有您能控制的密钥进行 端到端加密 。 这个加密后的“数据包”会被同步到您的 Apple iCloud 钥匙串或 Google 密码管理器中。 解密这个“数据包”的“钥匙”是什么？ 这把钥匙与您的 Apple ID / Google 账户密码、以及您信任的设备的锁屏密码/生物识别（Face ID, Touch ID, Windows Hello）强相关。 因此，核心在于 ： Apple 和 Google 无法解密 ：它们只负责存储这个加密后的“保险箱”（数据包），但没有打开保险箱的钥匙。钥匙分散在您的账户和设备上。 攻击者无法利用 ：即使攻击者黑进了 Google 或 Apple 的服务器，偷走的也只是一个无法解密的“保险箱”。 Windows Hello 的作用 ：当你在 Chrome 浏览器（登录了 Google 账户）的 Windows 电脑上使用 Passkey 时，Windows Hello（你的指纹或 PIN）就是用来授权 Chrome 访问和使用本地安全存储（TPM）中的私钥，或者是解密从 Google 云端同步过来的 Passkey 凭证。它是一个授权和解锁的动作。 总结与精炼 您的理解对在哪里 ：Passkey 的核心是密钥对，私钥在设备安全区，公钥在服务器，登录安全又方便。云同步的 Passkey 是被加密的，云厂商无法看到。 需要修正的细节 ：云端同步的不是简单“加密后的私钥”，而是一个 端到端加密的、可同步的 Passkey 凭证 。解密它的权力掌握在用户自己手中，通过账户和设备锁屏机制来共同实现。 可以这样比喻：\n- 设备绑定的 Passkey ：像一把焊死在你家门上的钥匙，谁也拿不走，但你去了别处就没法开门。\n- 可同步的 Passkey ：像一个超级保险箱，里面装着你所有门的"}, {"title": "age-note", "path": "posts/2025/age.html", "tags": ["age", "加密", "隐私"], "content": "age-note age 是一个简单的加密工具，旨在提供一种安全、易用的方式来加密文件和数据。它的设计理念是简洁和高效，适合需要快速加密和解密的场景。 生成密钥对 age-keygen -o key.txt\nPublic key: age1ql3z7hjy54pw3hyww5ayyfg7zqgvc7w3j2elw8zmrj2kg5sfn9aqmcac8p 加密文件 age -r age1ql3z7hjy54pw3hyww5ayyfg7zqgvc7w3j2elw8zmrj2kg5sfn9aqmcac8p secrets.txt > secrets.txt.age 解密文件 age -d -i key.txt secrets.txt.age > secrets.txt 使用密码加密 age -p secrets.txt > secrets.txt.age 解密时输入密码 age -d secrets.txt.age > secrets.txt 密钥对加解密 age -r age1t9xarklwwxyzcgftvc2m8s574lt4c0wl0ukgk7qmpl38ry3cruxs4f69r5 -o encrypted.age a.txt\nage -d -i key.txt -o decrypted.txt encrypted.age 密码加解密 age --passphrase -o encrypt.age a.txt\nage --decrypt -o a.txt encrypt.age"}, {"title": "背景颜色", "path": "posts/2025/background-color.html", "tags": ["Android", "Windows", "纯色背景"], "content": "背景颜色 专注内容的纯色背景 #374852"}, {"title": "PowerShell Get-Command 命令", "path": "posts/2025/powershell-get-command.html", "tags": ["PowerShell", "Windows"], "content": "PowerShell Get-Command 命令 检查所有 Path 变量 $env:Path -split ';' 用 Get-Command 检查 PowerShell 环境 Get-Command typst 这个命令会告诉你 typst 的实际可执行文件路径或是否是别名/函数 检查 scoop/shims 或其他包管理器路径 如果你用 scoop 安装的，路径可能类似 C:\\Users\\<用户名>\\scoop\\shims ，在 Path 里则应该有这项 例子 假如你用 Get-Command typst ，输出结果： PS C:\\Users\\24109> Get-Command typst\n\nCommandType     Name                                               Version    Source\n-----------     ----                                               -------    ------\nApplication     typst.exe                                          0.0.0.0    D:\\typst\\typst.exe 说明你的 typst 可执行文件在 D:\\typst 下 而如果是： CommandType     Alias\n-----------     -----\nAlias           typst -> ... 说明它其实是 PowerShell 的别名 如果是 scoop/shims 之类的特殊路径，确认 scoop 的 shims 路径已加入 Path"}, {"title": "在 zed 上配置 typstyle", "path": "posts/2025/zed_use_typstyle.html", "tags": ["zed", "Typst"], "content": "在 zed 上配置 typstyle 在 Zed 上配置 Typst 的格式化工具，在 settings.json 中写入以下即可 \"languages\": {\n\"Typst\": {\n            \"show_edit_predictions\": false,\n            \"format_on_save\": \"on\",\n            \"formatter\": {\n                \"external\": {\n                    \"command\": \"typstyle\"\n                }\n            }\n        }\n} Zed Typst 插件： https://github.com/weethet/typst.zed"}, {"title": "关闭 WPS 后台运行", "path": "posts/2025/shut-wps-background-runing.html", "tags": ["WPS"], "content": "关闭 WPS 后台运行 搬运自： https://www.zhihu.com/question/498031038 第一步 在 WPS 的安装路径下找到一个名为 ksomisc.exe 的文件，路径为 D:\\Kingsoft\\WPS Office\\12.1.0.21171\\office6\\ksomisc.exe 点击 ksomisc.exe ，进入到 “WPS综合修复/配置工具” 界面，进入 “高级” 界面，把里面 “功能定制” 和 “升级设置” 两个页面下的选项关掉 第二步 还是在 D:\\Kingsoft\\WPS Office\\12.1.0.21171\\office6 路径下，找到以下五个文件 wpscenter.exe wpscloudlaunch.exe wpscloudsvr.exe wpscloudsvrimp.dll wpsrenderer.exe 全删了，并右键新建五个 txt 文件，把名字改为以上五个名字，占用位置，以防死灰复燃 第三步 打开 “控制面板”，打开 “Windows 工具”，打开 “服务” 在 “服务” 界面中找到一个名为 “WPS Office Cloud Service” 的选项，右键点击属性，把里面 “常规” 项下的 “启动类型” 改为禁用，确定退出 关闭 WPS 增量备份 来源： https://www.bilibili.com/video/BV1QYEkzvEWQ 在 WPS 主页的右上角找到 “全局设置”，打开下面的 “设置” 在 “设置” 界面找到 “打开备份中心” 在 “备份中心” 界面中找到 “本地备份设置”，点击 “关闭备份” 按钮，关闭增量备份功能"}, {"title": "GitHub 头像", "path": "posts/2025/github-avatar.html", "tags": ["GitHub"], "content": "GitHub 头像 我的 GitHub 头像 Typst 版 #set page(width: 12cm, height: 12cm, margin: 0cm, fill: rgb(\"F0F0F0\"))\n\n#place(rect(fill: rgb(\"D3DF90\"), width: 2cm, height: 2cm), dx: 9cm, dy: 9cm)\n#place(rect(fill: rgb(\"D3DF90\"), width: 4cm, height: 2cm), dx: 7cm, dy: 1cm)\n#place(rect(fill: rgb(\"D3DF90\"), width: 2cm, height: 2cm), dx: 5cm, dy: 3cm)\n#place(rect(fill: rgb(\"D3DF90\"), width: 2cm, height: 4cm), dx: 3cm, dy: 5cm)\n#place(rect(fill: rgb(\"D3DF90\"), width: 2cm, height: 4cm), dx: 7cm, dy: 5cm)\n#place(rect(fill: rgb(\"D3DF90\"), width: 2cm, height: 2cm), dx: 1cm, dy: 9cm)\n#place(rect(fill: rgb(\"D3DF90\"), width: 2cm, height: 2cm), dx: 5cm, dy: 9cm)\n#place(rect(fill: rgb(\"D3DF90\"), width: 4cm, height: 2cm), dx: 1cm, dy: 1cm)"}, {"title": "Typst 语法简单介绍", "path": "posts/2025/typst-syntax-simple-introduction.html", "tags": ["Typst"], "content": "Typst 语法简单介绍 wardenxyz: 解释下 Typst 的 let 和 show GitHub Copilot: Typst 中的 let 和 show 是两个核心概念，用于变量绑定和内容样式化： let - 变量绑定 let 用于创建变量或函数绑定： // 绑定简单值\n#let name = \"张三\"\n#let age = 25\n\n// 绑定函数\n#let greet(person) = [Hello, #person!]\n\n// 使用变量\n#name 今年 #age 岁\n#greet(\"李四\") let 的特点：\n- 创建不可变绑定\n- 支持函数定义\n- 作用域局限于当前块 show - 样式规则 show 用于定义元素的显示样式： // 为特定元素类型设置样式\n#show heading: it => [\n  #set text(fill: blue)\n  #it.body\n]\n\n// 为特定内容设置样式\n#show \"重要\": strong\n\n// 条件样式\n#show heading.where(level: 1): it => [\n  #set text(size: 20pt)\n  #it\n]\n\n= 标题一\n这是*重要*内容。 show 的用法：\n- show selector: transformation - 基本语法\n- 可以匹配元素类型、内容或条件\n- 变换函数接收匹配的内容并返回新内容 组合使用 #let emphasis-color = red\n#show strong: it => text(fill: emphasis-color, it)\n\n这是*强调*文本。 这两个功能让 Typst 具有强大的自定义能力， let 管理数据和逻辑， show 控制视觉呈现。 wardenxyz: Typst 的函数是什么 GitHub Copilot: 在 Typst 中，函数是可重用的代码块，用于封装逻辑和生成内容。 函数定义 使用 let 定义函数： // 简单函数\n#let greet(name) = [Hello, #name!]\n\n// 带默认参数的函数\n#let format-date(day, month: \"January\", year: 2024) = [\n  #day #month, #year\n]\n\n// 返回内容的函数\n#let highlight(content, color: red) = [\n  #text(fill: color, weight: \"bold\")[#content]\n] 函数特点 参数支持 ：可以有位置参数和命名参数 默认值 ：参数可以有默认值 返回内容 ：函数返回 Typst 内容，用方括号 [] 包围 闭包特性 ：可以访问外部作用域的变量 高阶函数 // 接受函数作为参数\n#let apply-style(content, styler) = styler(content)\n\n#let make-bold = content => strong(content)\n#let make-italic = content => emph(content)\n\n#apply-style(\"重要文本\", make-bold)\n#apply-style(\"强调文本\", make-italic) 实际应用 // 创建卡片组件\n#let card(title, content, color: gray) = [\n  #rect(\n    fill: color.lighten(80%),\n    stroke: color,\n    inset: 1em,\n    radius: 4pt\n  )[\n    #strong(title)\n    #v(0.5em)\n    #content\n  ]\n]\n\n#card(\"提示\", [这是一个提示信息], color: blue) 函数让 Typst 代码更模块化和可重用，是构建复杂文档的重要工具。 wardenxyz: let 后面带着的是变量和函数，那 show 呢 GitHub Copilot: show 后面跟着的是 选择器 和 变换函数 ，用于定义样式规则。 show 的结构 基本语法： #show selector: transformation 选择器类型 // 1. 元素类型选择器\n#show heading: it => [...]\n#show strong: it => [...]\n#show table: it => [...]\n\n// 2. 字符串内容选择器\n#show \"重要\": strong\n#show \"TODO\": it => text(fill: red)[#it]\n\n// 3. 正则表达"}, {"title": "conda 使用笔记", "path": "posts/2025/conda_note.html", "tags": ["conda", "python"], "content": "conda 使用笔记 conda 常用命令 # 创建环境时指定 Python 版本\nconda create --name myenv python=3.8\n\n# 更精确的版本控制\nconda create --name myenv python=3.8.5\n\n# 激活环境\nconda activate env_name\n\n# 列出所有的 conda 虚拟环境\nconda env list\n\n# 删除 conda 虚拟环境\nconda remove --name myenv --all # 所有的环境\nconda env remove --name myenv # 删除指定环境\n\n# 在现有环境中安装/更新 Python 版本\nconda install python=3.8\n\n# 或者直接指定环境\nconda install -n myenv python=3.8\n\n# 列出当前环境的包\nconda list\n\n# 查看指定环境的包\nconda list -n env_name\n\n# 在当前环境搜索包\nconda list numpy\n\n# 在指定环境搜索\nconda list -n env_name numpy\n\n# 导出为 YAML 文件\nconda env export > environment.yml\n\n# 或只导出手动安装的包\nconda env export --from-history > environment.yml\n\n# 导入环境:\nconda env create -f environment.yml\n\n# 更新现有环境\nconda env update -f environment.yml\n\n# 查看可用的 Python 版本\nconda search python Python 虚拟环境管理 Python 学习笔记 ## 创建虚拟环境\npython -m venv venv\n\n## 激活虚拟环境\n.\\venv\\Scripts\\activate  ## Windows\n## 或者\nsource venv/bin/activate  ## macOS 和 Linux\n\n## 安装第三方库\npip install requests\n\n## 卸载第三方库\npip uninstall requests\n\n## 生成依赖文件\npip freeze > requirements.txt\n\n## 根据依赖文件下载第三方库\npip install -r requirements.txt\n\n## 根据依赖文件卸载第三方库\npip uninstall -r requirements.txt -y\n\n## 停用虚拟环境\ndeactivate"}, {"title": "正则表达式简明指南", "path": "posts/2025/regex-note.html", "tags": ["正则表达式"], "content": "正则表达式简明指南 核心元字符速查 元字符 功能描述 示例 匹配案例 . 匹配除换行符外的任意字符 a.c abc, a1c * 前导字符出现0次或多次 ab* a, ab, abb + 前导字符出现1次或多次 ab+ ab, abb ? 前导字符出现0次或1次 ab? a, ab ^ 匹配字符串起始位置 ^Start Start... $ 匹配字符串结束位置 End$ ...End [] 匹配括号内任意字符 [aeiou] a, e [^] 排除括号内字符 [^0-9] a, B, @ () 创建捕获组 (ab)+ ab, abab \\ 转义特殊字符 \\. . 字符类精要 基础形式 ： [A-Za-z] 匹配任意字母， [0-9] 匹配数字 组合用法 ： [\\w.-] 匹配字母/数字/下划线/点/连字符（常用邮箱验证） 排除匹配 ： [^aeiou] 匹配非元音字符 量词匹配模式 模式 符号 示例 匹配结果对比 贪婪匹配 * + ? a.*b axxxxyb中的全部内容 非贪婪匹配 *? +? ?? a.*?b axxxxyb中的第一个a和b之间的最短匹配 锚点定位技巧 ^2025- 匹配以\"2025-\"开头的字符串（如日期） -15$ 匹配以\"-15\"结尾的字符串 ^Hello$ 精确匹配整个字符串\"Hello\" 捕获组实战 基础分组 (\\d{4})-(\\d{2})-(\\d{2}) 匹配日期格式，捕获年/月/日 示例：2025-04-15 → Group1:2025 Group2:04 Group3:15 反向引用 (\\b\\w+)\\s+\\1 检测重复单词\n   - 匹配：\"hello hello\"中连续重复的\"hello\" 预定义字符类 符号 等效表达式 功能说明 \\d [0-9] 数字字符 \\w [A-Za-z0-9_] 单词字符（含下划线） \\s [ \\t\\n\\r] 空白字符（含空格/换行） \\D [^0-9] 非数字字符 高频使用技巧 手机号验证 ： ^1[3-9]\\d{9}$ 邮箱验证 ： ^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$ HTML标签匹配 ： <([a-z]+)([^<]+)*(?:>(.*)<\\/\\1>| *\\/>)"}, {"title": "在 Zed Editor 中配置 OpenAI API 兼容的模型", "path": "posts/2025/Zed_set_OpenAI_API_Compatible_model.html", "tags": ["zed"], "content": "在 Zed Editor 中配置 OpenAI API 兼容的模型 在 setting.json 中写入 \"language_models\": {\n        \"openai\": {\n            \"api_url\": \"https://dashscope.aliyuncs.com/compatible-mode/v1\",\n            \"available_models\": [\n                {\n                    \"name\": \"deepseek-r1\",\n                    \"display_name\": \"DeepSeek-R1\",\n                    \"max_tokens\": 65792,\n                    \"max_output_tokens\": 2056\n                },\n            ],\n            \"version\": \"1\"\n        }\n    }, 接下来，在 Zed Editor 的 Assistant Panel Configuration 界面中，\n找到 OpenAI 配置项，在此处输入阿里云 API 密钥，确认后按回车键保存配置。 完成上述步骤后，即可在 Zed Editor 中流畅地使用 AI 功能了。 感受 Zed 的 AI 功能不仅限于代码编写，更拓展到了创作领域。用户只需选中任意段落，即可轻松实现文章润色、多语言翻译或创意发想等操作 反观 VSCode 的 GitHub Copilot 功能，其适用范围相对局限，主要聚焦于代码开发领域。\n虽然有第三方插件，但与 vscode 的兼容性欠佳，难以获得与 GitHub Copilot 一致的优质体验。 Zed 有 Git、AI、实时协作 三大功能，我感觉基于 Zed 可以玩出更多花样来。"}]